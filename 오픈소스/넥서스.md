Nexus Repository는 개발에 필요한 모든 라이브러리와 파일을 중앙에서 관리하는 **멀티포맷 아티팩트 저장소**입니다.

## 왜 Nexus가 필요한가?

### 문제점
개발자들이 각자 외부 저장소에서 라이브러리를 다운로드하여 관리가 어렵고 비효율적입니다.

### 해결책
내부 서버에 모든 라이브러리를 모아두고 한 곳에서 중앙 관리합니다.

### 기본 방식 vs Nexus 방식

```yaml
기본 방식:
  개발자 → Maven Central (외부) → 라이브러리 다운로드

Nexus 방식:
  개발자 → Nexus (내부) → Maven Central → 라이브러리 다운로드
          ↑ 캐시/관리      ↑ 첫 번째만
```

## 주요 기능

### 1. 프록시 & 캐싱
- 외부 저장소(Maven Central, npm Registry)의 캐시 역할
- 한 번 다운로드하면 내부에서 재사용

### 2. 멀티포맷 지원
- **Docker 이미지**: 컨테이너 이미지 저장
- **Maven (Java)**: Java 라이브러리
- **npm (Node.js)**: JavaScript 패키지
- **PyPI (Python)**: Python 패키지
- **NuGet (.NET)**: .NET 패키지
- **Helm 차트**: 쿠버네티스 애플리케이션 패키지

### 3. 사내 라이브러리 저장
- 내부에서 개발한 라이브러리 공유
- 팀 간 코드 재사용

## 사용 시나리오

### 개인/소규모 팀 (95% 사용 안함)
- Maven Central 직접 사용
- 설정 간단, 비용 없음

### 중대형 기업 (80% 사용)
- 보안 정책, 망분리 환경
- 네트워크 효율성, 통제 필요

## 실제 설정 예시

### Maven 설정

```xml
<!-- pom.xml -->
<project>
    <!-- Repository 설정: 어디서 가져올지 -->
    <repositories>
        <repository>
            <id>nexus</id>
            <url>http://nexus.company.com:8081/repository/maven-public/</url>
        </repository>
    </repositories>
    
    <!-- 의존성 선언: 무엇을 가져올지 -->
    <dependencies>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-core</artifactId>
            <version>5.3.21</version>
        </dependency>
    </dependencies>
</project>
```

### 빌드 시 동작 과정

```bash
mvn clean compile
↓
Maven: pom.xml에서 의존성 목록 확인
↓  
Maven: "spring-core 5.3.21이 필요하네"
↓
Maven: Repository 설정 확인 → Nexus 서버 접근
↓
Nexus: spring-core 있는지 확인
  - 있으면: 바로 전달
  - 없으면: Maven Central에서 다운로드 후 캐시하고 전달
↓
빌드 완료
```

## Helm 레포지토리 기능

### Helm 차트 저장소 역할
Nexus는 Helm 차트를 저장하고 배포할 수 있는 레포지토리 역할을 합니다.

### Helm 레포지토리 추가 방법

1. **Nexus에서 Helm 레포지토리 생성**
   - Nexus UI에서 Helm hosted 레포지토리 생성
   - 예: `my-helm-repo`

2. **쿠버네티스 클러스터에서 Helm 레포지토리 등록**
   ```bash
   helm repo add my-nexus http://nexus.company.com:8081/repository/my-helm-repo/
   helm repo update
   ```

3. **Helm 차트 사용**
   ```bash
   # 레포지토리 목록 확인
   helm repo list
   
   # 레포지토리의 차트 목록 확인
   helm search repo my-nexus
   
   # 차트 설치
   helm install my-app my-nexus/my-chart
   ```

### Helm 차트 업로드 방법

```bash
# Helm 차트 패키징
helm package my-chart/

# Nexus에 업로드 (curl 사용)
curl -u admin:password -X POST \
  "http://nexus.company.com:8081/service/rest/v1/components?repository=my-helm-repo" \
  -H "accept: application/json" \
  -H "Content-Type: multipart/form-data" \
  -F "helm.asset=@my-chart-1.0.0.tgz"
```

## 장단점

### 장점
- 🚀 빠른 다운로드 (내부 네트워크)
- 🔒 보안 통제 (승인된 라이브러리만)
- 📦 통합 관리 (모든 아티팩트 한 곳에)
- 🏢 사내 라이브러리 공유

### 단점
- 💰 비용 (서버, 관리 인력)
- ⚙️ 설정 복잡성
- 🔧 유지보수 필요

## 경쟁 제품 비교

| 제품 | 특징 | 사용 환경 |
|------|------|-----------|
| **Nexus** | 멀티포맷, 기업급 | 대기업, CI/CD 중심 |
| **Harbor** | 컨테이너 전문 | 쿠버네티스 환경 |
| **Docker Hub** | 퍼블릭 클라우드 | 개인, 소규모 |

## 핵심 포인트

```yaml
언제 사용?: 
  - 기업 환경 (보안 정책)
  - 팀 규모 큼 (효율성)
  - 망분리 환경 (접근 제한)
  - 사내 라이브러리 공유

왜 사용?:
  - 의존성 "정보"는 코드에, "파일"은 별도 관리
  - 외부 의존성 없는 안정적 빌드
  - 중앙집중식 아티팩트 관리
```

**한줄 요약**: 개발팀의 모든 라이브러리를 안전하고 효율적으로 관리하는 내부 저장소

---

# Nexus Docker Registry 운영 가이드

## 목표

쿠버네티스 환경에서 Nexus를 Docker 이미지 저장소로 사용하고, 기존 VM에서 관리하던 이미지를 새 환경으로 안전하게 이전합니다.

## 설치 구조

### 기존 VM Nexus
- 회사에서 직접 VM에 Nexus 설치 운영
- 접속 URL: `https://14.63.177.157:8443/`
- Repository에 기존 Docker 이미지 저장
- **목적**: 이 이미지들을 파드로 배포된 Nexus로 마이그레이션

### 쿠버네티스 Nexus
- Helm Chart로 설치
- 서비스 노출 방식:
  - NodePort 30018 (HTTP Docker Port)
  - NodePort 30443 (HTTPS Docker Port)
  - ClusterIP 8081 (웹 UI/REST API)
- Ingress 배포되어 있으나 EXTERNAL-IP 없음 (NodePort만 노출)

## 마이그레이션 목적

- 기존 VM Nexus에 저장된 이미지 정보를 쿠버네티스 Nexus로 이전
- 새 환경에 동일한 이미지 네임과 태그로 저장
- 이후 구축된 쿠버네티스 클러스터에서 일관되게 Pull 가능

## 접근 방식

### NodePort (HTTPS) 방식
- 포트: `30443`
- HTTPS 인증서 CN/SAN 주의

```bash
sudo nerdctl tag nginx 172.25.0.84:30443/myimage/nginx:latest
sudo nerdctl push 172.25.0.84:30443/myimage/nginx:latest
```

### Ingress Subpath 방식
- DNS가 Ingress에 연결되어야 함
- `/etc/hosts`에 Ingress Node IP 등록 필요

**예시 `/etc/hosts`:**
```
172.25.0.96 repository.dev.eris.go.kr
```

**예시 Push:**
```bash
sudo nerdctl tag nginx repository.dev.eris.go.kr/my-repo/nginx:latest
sudo nerdctl push repository.dev.eris.go.kr/my-repo/nginx:latest
```

Repository가 `my-repo`로 구분됩니다.

## 기본 명령어

### 1. nerdctl 로그인
```bash
nerdctl login --insecure-registry 10.100.0.102:32415
```

프롬프트가 나오면 입력:
```
Username: admin
Password: <Nexus 비밀번호>
```

### 2. 이미지 태그 지정
```bash
nerdctl tag busybox:latest 10.100.0.102:32415/my-docker-image/busybox:latest
```

> `my-docker-image` = Nexus에 만든 Docker hosted repo 이름

### 3. 이미지 푸시
```bash
nerdctl --insecure-registry push 10.100.0.102:32415/my-docker-image/busybox:latest
```

### 4. 이미지 풀
```bash
nerdctl --insecure-registry pull 10.100.0.102:32415/my-docker-image/busybox:latest
```

> `--insecure-registry` 꼭 필요함 (HTTP 레지스트리라서)

### 5. 이미지 확인
```bash
nerdctl images
```

## 실제 사용 예시: cert-manager 이미지 이관

### 1. 필요한 이미지 Pull
```bash
nerdctl pull quay.io/jetstack/cert-manager-cainjector:v1.14.4
```

### 2. 이미지에 새로운 태그 달기
```bash
nerdctl tag quay.io/jetstack/cert-manager-cainjector:v1.14.4 \
  10.100.0.102:32415/my-docker-image/cert-manager-cainjector:v1.14.4
```

### 3. Nexus에 Push
```bash
# Nexus 로그인
nerdctl login --insecure-registry 10.100.0.102:32415

# 이미지 Push
nerdctl --insecure-registry push 10.100.0.102:32415/my-docker-image/cert-manager-cainjector:v1.14.4
```

### 4. YAML 파일의 이미지 경로 수정

**기존:**
```yaml
image: "quay.io/jetstack/cert-manager-cainjector:v1.14.4"
```

**변경:**
```yaml
image: "10.100.0.102:32415/my-docker-image/cert-manager-cainjector:v1.14.4"
```

### 5. 쿠버네티스에 적용
```bash
kubectl apply -f cert-manager.yaml
```

이제 인터넷이 끊어져도 Nexus에서 이미지를 가져올 수 있습니다.

## 트러블슈팅

### Push 실패 시 해결 방법

**에러 메시지:**
```
server "172.25.0.84:30018" does not seem to support HTTPS, falling back to plain HTTP
error="failed to do request: Head \"https://172.25.0.84:30018/...\": http: server gave HTTP response to HTTPS client"
```

**해결 방법:**

1. **containerd 설정 파일 생성**
   ```bash
   sudo mkdir -p /etc/containerd/certs.d/172.25.0.84:30018
   sudo vi /etc/containerd/certs.d/172.25.0.84:30018/hosts.toml
   ```

2. **설정 내용**
   ```
   server = "http://172.25.0.84:30018"

   [host."http://172.25.0.84:30018"]
     capabilities = ["pull", "resolve", "push"]
     skip_verify = true
   ```

3. **containerd 재시작**
   ```bash
   sudo systemctl restart containerd
   ```

## 요약

**Pull** → **Tag** → **Push** → **YAML 수정** → **적용**

이 과정을 통해 외부 의존성 없이 내부 Nexus에서 모든 이미지를 관리할 수 있습니다.