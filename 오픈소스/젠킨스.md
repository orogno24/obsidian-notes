## 🚀 Jenkins 기본 설치

### 1. Helm을 통한 Jenkins 설치

#### 저장소 추가 및 values.yaml 생성

```bash
# Jenkins Helm 저장소 추가
helm repo add jenkins https://charts.jenkins.io
helm repo update

# 기본 values.yaml 파일 생성
helm show values jenkins/jenkins > values.yaml
```

#### values.yaml 주요 설정

```yaml
controller:
  adminPassword: your-strong-password
  serviceType: ClusterIP  # Ingress 사용으로 NodePort 불필요
  ingress:
    enabled: false        # 수동으로 Ingress 생성 예정
  resources:
    requests:
      cpu: "500m"
      memory: "1Gi"
    limits:
      cpu: "1"
      memory: "2Gi"
  installPlugins:
    - kubernetes:latest
    - workflow-aggregator:latest
    - git:latest
    - configuration-as-code:latest
```

#### Jenkins 설치 실행

```bash
helm install jenkins jenkins/jenkins -n op-gitops -f values.yaml
```

### 2. 초기 설정

#### 관리자 비밀번호 확인

```bash
kubectl exec --namespace op-gitops -it svc/jenkins -c jenkins -- \
  /bin/cat /run/secrets/additional/chart-admin-password && echo
```

#### Self-Signed TLS 인증서 생성

```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
  -keyout jenkins-tls.key -out jenkins-tls.crt \
  -subj "/CN=jenkins.dev.gcp.go.kr/O=jenkins"

kubectl create secret tls jenkins-tls \
  --cert=jenkins-tls.crt \
  --key=jenkins-tls.key \
  -n op-gitops
```

### 3. Ingress 설정

```yaml
# jenkins-ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: jenkins-ingress
  namespace: op-gitops
  annotations:
    nginx.ingress.kubernetes.io/proxy-body-size: "1024m"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
spec:
  ingressClassName: nginx
  rules:
  - host: jenkins.dev.gcp.go.kr
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: jenkins
            port:
              number: 8080
  tls:
  - hosts:
    - jenkins.dev.gcp.go.kr
    secretName: jenkins-tls
```

```bash
kubectl apply -f jenkins-ingress.yaml
```

---

## ⚙️ Pod Template 설정

### Jenkins 관리 화면에서 설정

**경로**: Dashboard > Jenkins 관리 > Clouds > kubernetes > Pod templates

### 기본 Pod Template 구성

#### 1. 기본 설정

- **Name**: `test`
- **Namespace**: `op-gitops`
- **Labels**: `test-label`
- **Usage**: Only build jobs with label expressions matching this node

#### 2. JNLP Container 설정

```yaml
Name: jnlp
Docker image: jenkins/inbound-agent:latest
Working directory: /home/jenkins/agent
Command to run: (비워둠)
Arguments to pass to the command: ${computer.jnlpmac} ${computer.name}
```

**환경변수:**

- `JENKINS_URL`: `http://jenkins.op-gitops.svc.cluster.local:8080/`
- `DOCKER_HOST`: `tcp://localhost:2375`

#### 3. Docker-in-Docker Container 설정

```yaml
Name: docker-dind
Docker image: docker:dind
Working directory: /home/jenkins/agent
Command to run: dockerd
Arguments to pass to the command: --insecure-registry=harbor-core.op-common.svc.cluster.local:80 --insecure-registry=harbor.oke.com:30191
```

**환경변수:**

- `DOCKER_TLS_CERTDIR`: `""` (빈 값)

**고급 설정:**

- ✅ **Run in privileged mode** 체크

---

## 🔗 네트워크 설정 (Harbor 연동)

### CoreDNS 설정으로 내부 DNS 해결

```bash
# CoreDNS ConfigMap 수정
kubectl edit cm coredns -n kube-system
```

```yaml
# hosts 섹션 추가
hosts {
   10.178.0.3 harbor.oke.com  # 마스터 노드 IP, 도메인 이름 추가
   fallthrough
}
```

```bash
# CoreDNS 재시작
kubectl rollout restart deployment coredns -n kube-system
```

> 💡 **중요**: 쿠버네티스 파드는 노드의 `/etc/hosts`가 아닌 **CoreDNS 서버**를 통해 호스트 이름을 해석하므로, CoreDNS 설정 변경이 필요합니다.

---

## 🔧 빌드 파이프라인 구성

### 1. 파이프라인 Job 생성

#### 빌드 매개변수 설정

- **"이 빌드는 매개변수가 있습니다"** 옵션 선택
- 매개변수 추가: **Git Parameter**
    - **Name**: `SELECTED_TAG`
    - **Description**: `빌드할 Git 태그를 선택하세요`
    - **Default Value**: `latest`

#### Pipeline Script 설정

- **Pipeline script from SCM** 선택
- **SCM**: `Git`
- **Repository URL**: `http://gitea-http.op-gitops.svc:3000/pipeline/jenkins.git`
- **Credentials**: `git Credentials` 선택
- **Branch Specifier**: `origin/main`
- **Script Path**: `eris-fe/build/Jenkinsfile`

### 2. 빌드 파이프라인 스크립트 예시

```groovy
def runBuildPipeline() {
    // 🔧 Docker 이미지 URL 재계산
    env.DOCKER_IMAGE_URL = "${env.DOCKER_REGISTRY_HOST}/${env.DOCKER_PROJECT_NAME}/${env.DOCKER_IMAGE_NAME}"

    stage('Checkout') {
        checkout([
            $class: 'GitSCM',
            userRemoteConfigs: [[
                url: env.GIT_URL,
                credentialsId: env.GIT_CREDENTIALS_ID,
                refspec: '+refs/tags/*:refs/remotes/origin/tags/*'
            ]],
            branches: [[name: "refs/tags/${params.SELECTED_TAG}"]]
        ])
        env.APP_VERSION = params.SELECTED_TAG
        echo "✅ 선택한 태그로 체크아웃 완료: ${env.APP_VERSION}"
    }

    stage('Build') {
        sh 'chmod +x gradlew'
        sh './gradlew clean assemble --no-daemon'
        echo "✅ Gradle 빌드 완료"
    }

    stage('Test') {
        sh './gradlew test --no-daemon'
        junit '**/build/test-results/test/*.xml'
        echo "✅ 테스트 완료"
    }

    stage('Docker Build & Push') {
        container('docker-dind') {
            withCredentials([usernamePassword(
                credentialsId: env.DOCKER_REGISTRY_CREDENTIALS_ID,
                usernameVariable: 'DOCKER_USER',
                passwordVariable: 'DOCKER_PASS'
            )]) {
                echo "🔐 Docker 레지스트리에 로그인 중: ${env.DOCKER_REGISTRY_HOST}"
                sh """
                    echo "\$DOCKER_PASS" | docker login ${env.DOCKER_REGISTRY_HOST} -u "\$DOCKER_USER" --password-stdin
                    docker build -t ${env.DOCKER_IMAGE_URL}:${env.APP_VERSION} .
                    docker tag ${env.DOCKER_IMAGE_URL}:${env.APP_VERSION} ${env.DOCKER_IMAGE_URL}:latest
                    docker push ${env.DOCKER_IMAGE_URL}:${env.APP_VERSION}
                    docker push ${env.DOCKER_IMAGE_URL}:latest
                """
                echo "✅ Docker 이미지 푸시 완료: ${env.DOCKER_IMAGE_URL}:${env.APP_VERSION}"
            }
        }
    }

    stage('Git Manifest Push') {
        git(
            url: env.GITOPS_URL,
            branch: env.GITOPS_BRANCH,
            credentialsId: env.GITOPS_CREDENTIALS_ID
        )

        dir(env.GITOPS_DIR) {
            def currentVersion = sh(
                script: "grep -A1 'name: ${env.GITOPS_CONTAINER_NAME}' deployment.yaml | grep 'image:' | awk -F ':' '{print \$NF}'",
                returnStdout: true
            ).trim()

            echo "📦 현재 배포 중인 버전: ${currentVersion}"
            echo "🚀 새로 배포할 버전: ${env.APP_VERSION}"

            if (currentVersion != env.APP_VERSION) {
                echo "🔄 매니페스트 업데이트 시작"
                sh """
                    sed -i "/name: ${env.GITOPS_CONTAINER_NAME}/{n;s|image: .*|image: ${env.DOCKER_IMAGE_URL}:${env.APP_VERSION}|}" deployment.yaml
                    git config --global user.email "jenkins@okestro.com"
                    git config --global user.name "jenkins"
                    git add deployment.yaml
                    git commit -m "Update ${env.GITOPS_CONTAINER_NAME} image to ${env.APP_VERSION}"
                """

                withCredentials([usernamePassword(
                    credentialsId: env.GITOPS_CREDENTIALS_ID,
                    usernameVariable: 'GITOPS_USERNAME',
                    passwordVariable: 'GITOPS_PASSWORD'
                )]) {
                    sh "git push http://\${GITOPS_USERNAME}:\${GITOPS_PASSWORD}@${env.GITOPS_PATH} ${env.GITOPS_BRANCH}"
                }

                echo "✅ GitOps 매니페스트 업데이트 완료"
            } else {
                echo "⏩ 이미지 버전이 동일하여 매니페스트 업데이트 생략"
            }
        }
    }
}

return this
```

### 빌드 파이프라인 플로우

|단계|설명|결과물|
|---|---|---|
|**1. 변수 계산**|Docker 이미지 경로를 env 기반으로 계산|이미지 URL 설정|
|**2. Git 태그 체크아웃**|사용자가 선택한 태그로 소스 가져오기|소스 코드|
|**3. 빌드**|Gradle로 jar 생성|실행 가능한 jar|
|**4. 테스트**|Gradle로 JUnit 실행, 결과 보고|테스트 결과|
|**5. Docker 이미지 생성/푸시**|빌드한 앱을 Docker로 만들고 레지스트리에 푸시|Docker 이미지|
|**6. GitOps 배포 파일 수정**|deployment.yaml에서 image: 값을 새 버전으로 변경|업데이트된 매니페스트|
|**7. Git 커밋 + 푸시**|GitOps 저장소에 푸시 → 자동 배포 유발|배포 트리거|

---

## ↩️ 롤백 파이프라인 구성

### 1. 롤백 Job 생성

#### 빌드 매개변수 설정

- **"이 빌드는 매개변수가 있습니다"** 옵션 선택
- 매개변수 추가: **Git Parameter**
    - **Name**: `SELECTED_TAG`
    - **Description**: `롤백할 Git 태그를 선택하세요`
    - **Default Value**: `latest`

#### Pipeline Script 설정

- **Pipeline script from SCM** 선택
- **Repository URL**: `http://gitea-http.op-gitops.svc:3000/pipeline/jenkins.git`
- **Script Path**: `eris-fe/rollback/Jenkinsfile`

### 2. 롤백 파이프라인 스크립트 예시

```groovy
def checkout() {
    echo "🟦 [Git Checkout] - 시작"

    git(
        url: env.GIT_URL,
        branch: env.GIT_BRANCH,
        credentialsId: env.GIT_CREDENTIALS_ID
    )

    echo "✅ [Git Checkout] - 완료"
}

def gitOpsRollback() {
    echo "🟨 [GitOps Rollback] - 시작"

    git(
        url: env.GITOPS_URL,
        branch: env.GITOPS_BRANCH,
        credentialsId: env.GITOPS_CREDENTIALS_ID
    )

    dir(env.GITOPS_DIR) {
        withCredentials([usernamePassword(
            credentialsId: env.GITOPS_CREDENTIALS_ID,
            passwordVariable: 'GITOPS_PASSWORD',
            usernameVariable: 'GITOPS_USERNAME'
        )]) {
            def currentVersion = sh(
                script: "grep 'image:' deployment.yaml | awk -F ':' '{print \$NF}' | head -n 1",
                returnStdout: true
            ).trim()

            echo "🔍 현재 배포 중인 이미지 버전: ${currentVersion}"
            echo "🎯 롤백할 대상 태그: ${params.SELECTED_TAG}"

            if (currentVersion != params.SELECTED_TAG) {
                echo "🔄 롤백을 진행합니다. 매니페스트를 ${params.SELECTED_TAG} 태그로 업데이트합니다."

                sh """
                    sed -i "/name: ${env.GITOPS_CONTAINER_NAME}/{n;s|image: .*|image: ${env.DOCKER_IMAGE_URL}:${params.SELECTED_TAG}|}" deployment.yaml
                    git config --global user.email "jenkins@okestro.com"
                    git config --global user.name "jenkins"
                    git add deployment.yaml
                    git commit -m "Rollback to image version: ${params.SELECTED_TAG}"
                    git push http://${GITOPS_USERNAME}:${GITOPS_PASSWORD}@${env.GITOPS_PATH} ${env.GITOPS_BRANCH}
                """

                echo "✅ 롤백 완료: ${params.SELECTED_TAG} 태그로 배포 파일이 업데이트되었습니다."
            } else {
                echo "⏩ 현재 버전과 동일하여 롤백을 건너뜁니다."
            }
        }
    }

    echo "🟩 [GitOps Rollback] - 종료"
}

return this
```

### 롤백 파이프라인 플로우

|과정|설명|목적|
|---|---|---|
|**1. 태그 선택**|Jenkins에서 롤백할 Git 태그를 선택함|복원할 버전 지정|
|**2. 현재 상태 확인**|GitOps repo에서 현재 배포 버전 확인|중복 작업 방지|
|**3. 변경 판단**|현재와 선택한 태그가 다르면 롤백 진행|효율성 확보|
|**4. 매니페스트 수정**|`deployment.yaml`의 이미지 태그 변경|롤백 실행|
|**5. Git push**|수정된 매니페스트를 Git에 푸시|GitOps 트리거|
|**6. 자동 배포**|ArgoCD가 변경 감지 후 자동 재배포|실제 롤백|
|**7. 결과 출력**|Jenkins 로그로 성공 여부 출력|상태 확인|

### 빌드 vs 롤백 파이프라인 비교

|항목|**빌드 파이프라인**|**롤백 파이프라인**|
|---|---|---|
|**목적**|새로운 이미지 빌드 및 배포|기존 빌드된 이미지로 재배포|
|**Docker 이미지**|새로 빌드함|**이미 존재하는 이미지만 사용**|
|**GitOps 매니페스트**|빌드 후 변경|**선택한 태그로만 이미지 태그 교체**|
|**속도**|느림 (빌드, 테스트, 푸시 포함)|**빠름 (매니페스트만 수정)**|
|**위험성**|빌드에 따라 예기치 못한 변화 발생 가능|**이미 검증된 이미지만 사용하므로 안정적**|

---

## 🔍 트러블슈팅

### GitParameter 관련 문제

#### 증상

- GitParameter를 처음 사용하면 "No Git repository configured" 오류 발생
- 일반 파이프라인 한 번 실행 후에는 갑자기 정상 작동

#### 기술적 원인

**첫 접근 시:**

- Jenkins가 Git 저장소에 처음 접근하려고 시도
- 인증 정보, 네트워크 연결, 저장소 구조 등이 아직 준비되지 않음
- GitParameter가 필요한 정보를 가져오지 못함

**일반 파이프라인 실행 후:**

- Git 저장소 접근 방법을 "학습"
- 인증 정보 확인 완료
- 저장소 구조를 캐시에 저장
- 네트워크 경로 최적화
- → GitParameter가 필요한 정보를 쉽게 가져올 수 있음

#### 해결 방법

**1. 단계적 접근법 (권장)**

1. 간단한 파이프라인 만들기 (GitParameter 없이)
2. 한 번 실행해서 Git 연결 초기화하기
3. GitParameter 추가하기

**2. 사전 초기화 코드**

```groovy
stage('Git 초기화') {
    steps {
        sh 'git ls-remote ${저장소_주소}'
    }
}
```

**3. 실무 권장사항**

- 새 파이프라인 만들 때 처음부터 복잡한 기능 넣지 않기
- 가장 기본적인 형태로 먼저 실행해보기
- 성공 확인 후 GitParameter 같은 고급 기능 추가하기

### 일반적인 문제들

#### Pod Template 설정 관련

- **initializeOnce**: `false` → `true`로 변경 필요
- **경로**: Dashboard > Jenkins 관리 > Clouds > kubernetes > test

#### DNS 해결 문제

- CoreDNS 설정 후 재시작 필수
- Harbor와 같은 내부 서비스 연동 시 반드시 필요

---

## 📋 중요 정보 모음

### 인증 정보

```bash
# Gitea 토큰
9e65a62c74853285136ebc78520f17b2a43cdd45

# Harbor 로봇계정
vRXmR1iIAbCe7WteWRhc7idC4Axb05Px
```

### 네트워크 정보

```bash
# 외부 IP
34.47.118.180

# 내부 DNS 주소들
Gitea: http://gitea-http.op-gitops.svc:3000/test-app/backend-gitea.git
Jenkins: http://jenkins.op-gitops.svc.cluster.local:8080/
Harbor: harbor-core.op-common.svc.cluster.local:80
```

### 주요 설정값

```bash
# Repository URL 작성 시 주의사항
# ✅ 올바른 예시:
http://gitea-http.op-gitops.svc:3000/pipeline/jenkins.git

# ❌ 잘못된 예시:
http://gitea-http.op-gitops.svc:3000/pipeline/jenkins/eris-fe/rollback/Jenkinsfile
```

### Jenkins 플러그인 필수 목록

- `kubernetes:latest`
- `workflow-aggregator:latest`
- `git:latest`
- `configuration-as-code:latest`

### 환경변수 템플릿

```bash
# Docker 관련
DOCKER_REGISTRY_HOST=harbor.oke.com:30191
DOCKER_PROJECT_NAME=library
DOCKER_IMAGE_NAME=your-app
DOCKER_HOST=tcp://localhost:2375
DOCKER_TLS_CERTDIR=""

# Git 관련
GIT_URL=http://gitea-http.op-gitops.svc:3000/your-org/your-repo.git
GIT_CREDENTIALS_ID=git-credentials
GIT_BRANCH=main

# GitOps 관련
GITOPS_URL=http://gitea-http.op-gitops.svc:3000/your-org/gitops-repo.git
GITOPS_CREDENTIALS_ID=gitops-credentials
GITOPS_BRANCH=main
GITOPS_DIR=manifests
GITOPS_CONTAINER_NAME=your-container

# Jenkins 관련
JENKINS_URL=http://jenkins.op-gitops.svc.cluster.local:8080/
```

---

실제 파이프라인

pipeline {
    parameters {
        gitParameter(
            name: 'SELECTED_TAG',
            description: '배포할 Git 태그를 선택하세요',
            type: 'PT_TAG',
            branch: 'main',
            branchFilter: 'origin/(.*)',
            defaultValue: 'latest',
            useRepository: 'http://gitea-http:3000/eris/nlbs-svc.git',
            sortMode: 'DESCENDING_SMART'
        )   
    }
    agent {
        kubernetes {
            label 'dind'
        }
    }
    tools {
        jdk 'jdk-17'
    }
    
    environment {
        GIT_URL = 'http://gitea-http:3000/eris/nlbs-svc.git'
        GIT_CREDENTIALS_ID = 'gitea-jenkins-token'
        GIT_BRANCH = 'main'
        SONAR_HOST_URL = 'http://sonarqube-sonarqube.op-common.svc.cluster.local:9000'
        SONAR_PROJECT_KEY = 'eris-fe-nlbs'
        SONAR_PROJECT_NAME = '재난피해자위치정보조회시스템'
        GITOPS_URL = 'http://gitea-http:3000/git-ops/kustomize.git'
        GITOPS_PATH = 'gitea-http:3000/git-ops/kustomize.git'
        GITOPS_CREDENTIALS_ID = 'gitea-jenkins-token'
        GITOPS_BRANCH = 'main'
        GITOPS_DIR = 'eris-fe/nlbs-svc/overlay/dev'
        GITOPS_CONTAINER_NAME = 'eris-fe-nlbs'
        DOCKER_REGISTRY_URL = 'harbor-core:80'
        DOCKER_PROJECT_NAME = 'eris'
        DOCKER_IMAGE_NAME = 'eris/nlbs-svc'
        DOCKER_REPO_NAME = 'nlbs-svc'
        DOCKER_IMAGE_URL = 'harbor.dev.eris.go.kr:32443/eris/nlbs-svc'
        DOCKER_REGISTRY_CREDENTIALS_ID = 'eris-dev'
        HARBOR_SERVER = 'Harbor'
        MAVEN_HOME = '/usr/share/maven'
        PATH = "${env.MAVEN_HOME}/bin:${env.PATH}"
    }

    stages {
        stage('Load and Run') {
            steps {
                script {
                    def core = load 'common/core.groovy'
                    core.checkout()
                    core.mavenBuild2()
                    core.mavenTest()
                    core.sonarAnalysis()
                    core.sonarAnalysisResult()
                    core.dockerBuild()
                    core.dockerPush()
                    core.harborImageScan()
                    core.gitOpsDeploy()
                }
            }
        }
    }
}

def checkout() {
    stage('Git Checkout') {
        try {
            echo("===============[Git Checkout] 단계 시작===============")
            
            git (
                url: env.GIT_URL, 
                branch: env.GIT_BRANCH, 
                credentialsId: env.GIT_CREDENTIALS_ID, 
            )

            env.APP_VERSION = params.SELECTED_TAG
            if (params.SELECTED_TAG) {
                def tagExists = sh(
                    script: "git tag -l ${params.SELECTED_TAG}",
                    returnStdout: true
                ).trim()
                
                if (!tagExists) {   

                    echo("선택한 태그 ${params.SELECTED_TAG}가 존재하지 않습니다.")
                    env.APP_VERSION = sh(
                        script: "git tag --sort=-v:refname | head -n 1",
                        returnStdout: true
                    ).trim()
                }
            }
            echo("App Version: ${env.APP_VERSION}")
            sh("git checkout ${env.APP_VERSION}")

            echo("===============[Git Checkout] 단계 종료===============")
        } catch (err) {
            echo("[Git Checkout] 실패: ${err}")
            error("Git 체크아웃 단계에서 오류 발생")
        }
    }
}

def build() {
    stage('Build') {
        try {
            echo("===============[Build] 단계 시작===============")

            if (params.BUILD_TOOL == 'gradle') {
                gradleBuild()
            } else if (params.BUILD_TOOL == 'maven') {
                mavenBuild()
            } else {
                error("지원하지 않는 빌드 도구입니다.")
            }

            echo("===============[Build] 단계 종료===============")
        } catch (err) {
            echo("[Build] 실패: ${err}")
            error("빌드 단계에서 오류 발생")
        }
    }
}

def test() {
    stage('Test') {
        echo("===============[Test] 단계 시작===============")

        script {
            try {
                if (params.BUILD_TOOL == 'gradle') {
                    gradleTest()
                } else if (params.BUILD_TOOL == 'maven') {
                    mavenTest()
                } else {
                    error("지원하지 않는 빌드 도구입니다.")
                }
            } catch (err) {
                echo("[Test] 실패: ${err}")
                error("테스트 단계에서 오류 발생")
            }
        }
    }
}

def gradleTest() {
    stage('Gradle Test') {
        echo("===============[Gradle Test] 단계 시작===============")

        script {
            try {
                sh('chmod +x ./gradlew')
                sh('./gradlew test')
                echo('JUnit Test 성공적으로 실행 완료')
            } catch (err) {
                echo('JUnit Test 실패')
            } finally {
                // 리포트가 있는지 확인
                sh('ls -al build/test-results/test || echo "리포트 디렉토리 없음"')

                // junit은 리포트가 없으면 에러를 발생시키므로, 존재 확인 후 처리
                def reportsExist = fileExists('build/test-results/test')
                if (reportsExist) {
                    junit('**/build/test-results/test/*.xml')
                } else {
                    echo 'JUnit 리포트 파일이 존재하지 않아 junit 스텝을 건너뜁니다.'
                }
            }
        }
    }
}

def mavenTest() {
    stage('Maven Test') {
        echo("===============[Maven Test] 단계 시작===============")

        script {
            try {
                sh('mvn test')
                echo('JUnit Test 성공적으로 실행 완료')
            } catch (err) {
                echo('JUnit Test 실패')
            } finally {
                // 리포트가 있는지 확인
                sh('ls -al target/surefire-reports || echo "리포트 디렉토리 없음"')

                // junit은 리포트가 없으면 에러를 발생시키므로, 존재 확인 후 처리
                def reportsExist = fileExists('target/surefire-reports')
                if (reportsExist) {
                    junit('**/target/surefire-reports/*.xml')
                } else {
                    echo 'JUnit 리포트 파일이 존재하지 않아 junit 스텝을 건너뜁니다.'
                }
            }
        }
    }
}

def gradleBuild() {
    stage('Gradle Build') {
        echo("===============[Gradle Build] 단계 시작===============")

        script {
            def lastError = null
            retry(3) {
                try {
                    sh('chmod +x ./gradlew')
                    sh('./gradlew clean build -x test --no-daemon')
                } catch (err) {
                    lastError = err
                    
                    if (err.getMessage().contains('not found') || err.getMessage().contains('Permission denied')) {
                        echo "Gradle 실행 자체 실패 (Gradle down)"
                    } else {
                        echo "Gradle 빌드 실패 (컴파일/빌드 오류)"
                    }
                    throw err
                }
            }
        }

        echo("===============[Gradle Build] 단계 종료===============")
    }
}

def mavenBuild() {
    stage('Maven Build') {
        echo("===============[Maven Build] 단계 시작===============")

        script {
            def lastError = null
            retry(3) {
                try {
                    sh('mvn clean install -DskipTests')
                } catch (err) {
                    lastError = err

                    if (err.getMessage().contains('not found') || err.getMessage().contains('Permission denied')) {
                        echo("Maven 실행 자체 실패 (Maven down)")
                    } else {
                        echo("Maven 빌드 실패 (컴파일/빌드 오류)")
                    }
                    throw err
                }
            }
        }

        echo("===============[Maven Build] 단계 종료===============")
    }
}

def mavenBuild2() {
    stage('Maven Build') {
        echo("===============[Maven Build] 단계 시작===============")

        script {
            def lastError = null
            retry(3) {
                try {
                    sh('''
                        curl -L http://nexus.dev.eris.go.kr:32080/repository/okestro-raw/maven/apache-maven-3.9.9-bin.tar.gz -o /tmp/apache-maven-3.9.9-bin.tar.gz
                        rm -rf /usr/share/maven
                        tar -xzf /tmp/apache-maven-3.9.9-bin.tar.gz -C /usr/share
                        mv /usr/share/apache-maven-3.9.9 /usr/share/maven
                        rm /tmp/apache-maven-3.9.9-bin.tar.gz
                        export MAVEN_HOME=/usr/share/maven
                        export PATH=$MAVEN_HOME/bin:$PATH
                        mv /home/jenkins/agent/workspace/dev/fe/build/dev-nlbs/settings.xml /usr/share/maven/conf/ || true
                        mvn -version
                        mvn -U clean install -DskipTests -Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true
                    ''')
                } catch (err) {
                    lastError = err

                    if (err.getMessage().contains('not found') || err.getMessage().contains('Permission denied')) {
                        echo("Maven 실행 자체 실패 (Maven down)")
                    } else {
                        echo("Maven 빌드 실패 (컴파일/빌드 오류)")
                    }
                    throw err
                }
            }
        }

        echo("===============[Maven Build] 단계 종료===============")
    }
}

def sonarAnalysis() {
    stage('Sonar Analysis') {
        script {
            try {
                echo("===============[Sonar Analysis] 단계 시작===============")

                if (params.BUILD_TOOL == 'gradle') {
                    gradleSonarAnalysis()
                } else if (params.BUILD_TOOL == 'maven') {
                    mavenSonarAnalysis()
                } else {
                    error("지원하지 않는 빌드 도구입니다.")
                }

                echo("===============[Sonar Analysis] 단계 종료===============")
            } catch (err) {
                echo("[Sonar Analysis] 실패: ${err}")
            }
        }
    }
}

def gradleSonarAnalysis() {
    stage('Gradle Sonar Analysis') {
        script {
            try {
                echo("===============[Gradle Sonar Analysis] 단계 시작===============")

                withSonarQubeEnv('sonarqube') {
                    sh('chmod +x gradlew')
                    sh("""
                        ./gradlew sonar --no-daemon \\
                            -Dsonar.projectKey=${env.SONAR_PROJECT_KEY} \\
                            -Dsonar.projectName='${env.SONAR_PROJECT_NAME}' \\
                            -Dsonar.host.url=${env.SONAR_HOST_URL} \\
                            -Dsonar.java.binaries=./build/classes/java/main
                    """)
                }

                echo("===============[Gradle Sonar Analysis] 단계 종료===============")
            } catch (err) {
                echo("[Gradle Sonar Analysis] 실패: ${err}")
                echo("경고: Gradle Sonar Analysis 단계에서 오류가 발생했지만 파이프라인은 계속 진행됩니다.")
            }
        }
    }
}

def mavenSonarAnalysis() {
    stage('Maven Sonar Analysis') {
        script {
            try {
                echo("===============[Maven Sonar Analysis] 단계 시작===============")

                withSonarQubeEnv('sonarqube') {
                    // Maven Wrapper가 없는 경우 mvn 명령어 직접 사용
                    def mvnCmd = fileExists('./mvnw') ? './mvnw' : 'mvn'
                    
                    if (mvnCmd == './mvnw') {
                        sh("chmod +x ${mvnCmd}")
                    }
                    
                    sh("""
                        ${mvnCmd} sonar:sonar \\
                            -Dsonar.projectKey=${env.SONAR_PROJECT_KEY} \\
                            -Dsonar.projectName='${env.SONAR_PROJECT_NAME}' \\
                            -Dsonar.host.url=${env.SONAR_HOST_URL}
                    """)
                }

                echo("===============[Maven Sonar Analysis] 단계 종료===============")
            } catch (err) {
                echo("[Maven Sonar Analysis] 실패: ${err}")
                echo("경고: Maven Sonar Analysis 단계에서 오류가 발생했지만 파이프라인은 계속 진행됩니다.")
            }
        }
    }
}



def sonarAnalysisResult() {
    stage('Sonar Analysis Result') {
        script {
            try {
                echo("===============[Sonar Analysis Result] 단계 시작===============")

                // report-task.txt 파일 존재 여부 확인
                def reportTaskExists = fileExists('build/sonar/report-task.txt')
                if (!reportTaskExists) {
                    echo("SonarQube 분석 결과 파일(report-task.txt)이 존재하지 않습니다. 품질 게이트 검사를 건너뜁니다.")
                    echo("===============[Sonar Analysis Result] 단계 종료===============")
                    return
                }

                withSonarQubeEnv('sonarqube') {                                   
                    timeout(time: 3, unit: 'MINUTES') {                            
                        try {
                            def qg = waitForQualityGate()
                            echo("소나큐브 품질 게이트 검사 결과: ${qg.status}")
                            if (qg.status != 'OK') {
                                echo("소나큐브 품질 게이트 검사 실패: ${qg.status}")
                                echo("경고: 품질 게이트 검사에 실패했지만 파이프라인은 계속 진행됩니다.")
                            } else {
                                echo("소나큐브 품질 게이트 검사 통과")
                            }
                        } catch (org.jenkinsci.plugins.workflow.steps.FlowInterruptedException e) {
                            echo("소나큐브 분석 결과 대기 중 타임아웃이 발생했습니다.")
                            echo("경고: 타임아웃이 발생했지만 파이프라인은 계속 진행됩니다.")
                        } catch (Exception e) {
                            echo("소나큐브 품질 게이트 검사 중 오류 발생: ${e.message}")
                            echo("경고: 오류가 발생했지만 파이프라인은 계속 진행됩니다.")
                        }
                    }
                }

                echo("===============[Sonar Analysis Result] 단계 종료===============")
            } catch (err) {
                echo("[Sonar Analysis Result] 실패: ${err}")
                echo("경고: Sonar Analysis Result 단계에서 오류가 발생했지만 파이프라인은 계속 진행됩니다.")
            }
        }
    }
}

def dockerBuild() {
    stage('Docker Build') {
        try {
            echo("===============[Docker Build] 단계 시작===============")

            container('docker-dind') {
                sh("docker build -t ${env.DOCKER_REGISTRY_URL}/${env.DOCKER_IMAGE_NAME}:${env.APP_VERSION} .")
                sh("docker tag ${env.DOCKER_REGISTRY_URL}/${env.DOCKER_IMAGE_NAME}:${env.APP_VERSION} ${env.DOCKER_REGISTRY_URL}/${env.DOCKER_IMAGE_NAME}:latest")
            }

            echo("===============[Docker Build] 단계 종료===============")
        } catch (err) {
            echo("Docker Build 실패: ${err.getMessage()}")
            error("Docker Build 단계에서 오류 발생")
        }
    }
}

def dockerPush() {
    stage('Docker Push') {
        echo("===============[Docker Push] 단계 시작===============")

        container('docker-dind') {
            withCredentials([usernamePassword(
                credentialsId: 'eris-dev',
                usernameVariable: 'HARBOR_USER',
                passwordVariable: 'HARBOR_PASS'
            )]) {
                sh """
                        echo '$HARBOR_PASS' | docker login "${DOCKER_REGISTRY_URL}" -u '$HARBOR_USER' --password-stdin
                        docker push ${DOCKER_REGISTRY_URL}/${DOCKER_IMAGE_NAME}:${APP_VERSION}
                    """
            }
        }

        echo("===============[Docker Push] 단계 종료===============")
    }
}

def harborImageScan() {
    stage('Harbor Image Scan') {
        echo("===============[Harbor Image Scan] 단계 시작===============")

        script {
            withCredentials([usernamePassword(
                credentialsId: 'eris-dev',
                usernameVariable: 'HARBOR_USER',
                passwordVariable: 'HARBOR_PASS'
            )]) {
                sh("""
                    curl -v -k -X POST -u '$HARBOR_USER:$HARBOR_PASS' \\
                        'http://${DOCKER_REGISTRY_URL}/api/v2.0/projects/${DOCKER_PROJECT_NAME}/repositories/${DOCKER_REPO_NAME}/artifacts/${APP_VERSION}/scan'
                """)

                def maxWait = 150   // 최대 2분 30초 대기
                def interval = 10   // 10초마다 재시도
                def waited = 0
                def vulnResult = '{}'
                def found = false

                while (waited < maxWait) {
                    vulnResult = sh(
                        script: """
                            curl -sk -u "$HARBOR_USER:$HARBOR_PASS" \
                            "http://${DOCKER_REGISTRY_URL}/api/v2.0/projects/${DOCKER_PROJECT_NAME}/repositories/${DOCKER_REPO_NAME}/artifacts/${APP_VERSION}/additions/vulnerabilities"
                        """,
                        returnStdout: true
                    ).trim()
                    
                    if (vulnResult != '{}' && vulnResult != '[]' && vulnResult.length() > 5) {
                        found = true
                        break
                    }
                    echo("아직 취약점 데이터가 없습니다. ${interval}초 후 재시도 (경과: ${waited}s)")
                    sleep interval
                    waited += interval
                }

                if (!found) {
                    error("Harbor 취약점 결과를 ${maxWait}초 내에 받지 못했습니다.")
                }

                // 3. JSON 파싱 및 등급/코드 추출
                def parsed = readJSON text: vulnResult
                def reportKey = parsed.keySet().find { it.startsWith('application/vnd.scanner.adapter.vuln.report.harbor') }
                def report = parsed[reportKey]
                def severity = report?.severity ?: 'Unknown'
                def vulnerabilities = report?.vulnerabilities ?: []

                // 등급/코드 콘솔 출력
                echo("취약점 등급 : ${severity}")
                def cveList = vulnerabilities.collect { it.id }.join(', ')
                echo("취약점 코드 : ${cveList ?: '없음'}")

                // 4. 등급에 따라 분기
                if (severity.toLowerCase() == 'critical') {
                    echo("Critical 취약점 발견")
                    // 임시 허용
                    // error("Critical 취약점 발견: 파이프라인 실패 처리")
                } else {
                    echo("Critical 취약점 없음, docker push latest 실행")
                    container('docker-dind') {
                        withCredentials([usernamePassword(
                            credentialsId: 'eris-dev',
                            usernameVariable: 'HARBOR_USER',
                            passwordVariable: 'HARBOR_PASS'
                        )]) {
                            sh("docker push ${DOCKER_REGISTRY_URL}/${DOCKER_IMAGE_NAME}:latest")
                        }
                    }
                }
                echo("취약점 상세 결과: ${vulnResult}")
            }
        }
        echo("===============[Harbor Image Scan] 단계 종료===============")
    }
}

def gitOpsDeploy() {
    stage('GitOps Deploy') {
        echo("===============[GitOps Deploy] 단계 시작===============")

        git (
            url: env.GITOPS_URL,
            branch: env.GITOPS_BRANCH,
            credentialsId: env.GITOPS_CREDENTIALS_ID
        )

        script {
            dir(env.GITOPS_DIR){
                withCredentials([usernamePassword(credentialsId: env.GITOPS_CREDENTIALS_ID, passwordVariable: 'GITOPS_PASSWORD', usernameVariable: 'GITOPS_USERNAME')]) {

                    def currentVersion = sh(script: "grep 'newTag:' kustomization.yaml | awk -F ':' '{print \$2}' | head -n 1", returnStdout: true).trim()
                    echo("현재 버전: ${currentVersion}")
                    echo("신규 버전: ${env.SELECTED_TAG}")
                    
                    if (currentVersion != env.SELECTED_TAG) {
                        echo("버전이 다릅니다. 업데이트를 진행합니다.")
                        sh("""
                                sed -i "s|newTag: ${currentVersion}|newTag: \"${env.SELECTED_TAG}\"|g" kustomization.yaml
                                git config --global user.email "jenkins@okestro.com"
                                git config --global user.name "jenkins"
                                git add kustomization.yaml
                                git commit -m "Update image version: ${env.SELECTED_TAG}"
                                git push http://${GITOPS_USERNAME}:${GITOPS_PASSWORD}@${GITOPS_PATH} ${GITOPS_BRANCH}
                            """)                                        
                    } else {
                        echo("버전이 동일합니다. 업데이트가 필요하지 않습니다.")
                    }
                }
            }
        }
        echo("===============[GitOps Deploy] 단계 종료===============")
    }
}

return this


