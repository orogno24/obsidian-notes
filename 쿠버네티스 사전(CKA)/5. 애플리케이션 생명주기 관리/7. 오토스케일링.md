## 1. 스케일링의 기본 개념

스케일링은 시스템의 용량을 조정하여 애플리케이션 부하를 처리하는 방식입니다.
### 전통적인 서버 스케일링

1. **수직적 스케일링 (Vertical Scaling)**
    - 기존 서버에 더 많은 리소스(CPU, 메모리) 추가
    - 애플리케이션을 중단하고 서버 업그레이드 후 다시 시작
    - 일명 "Scale Up" 방식

2. **수평적 스케일링 (Horizontal Scaling)**
    - 더 많은 서버를 추가하여 부하 분산
    - 여러 인스턴스로 애플리케이션 실행
    - 기존 서버 중단 없이 확장 가능
    - 일명 "Scale Out" 방식

> 💡 **핵심 차이**: 수직적 스케일링은 기존 시스템의 크기를 키우는 것이고, 수평적 스케일링은 동일한 시스템을 여러 개 추가하는 것입니다.

## 2. 쿠버네티스의 스케일링 유형

쿠버네티스에서 스케일링은 크게 두 가지 차원으로 나눌 수 있습니다:

### A. 스케일링 대상에 따른 구분

1. **워크로드 스케일링**
    - 파드(컨테이너)의 수 또는 리소스 조정
    - 애플리케이션 레벨의 스케일링
    
2. **클러스터 스케일링**
    - 쿠버네티스 클러스터의 노드(서버) 수 또는 리소스 조정
    - 인프라스트럭처 레벨의 스케일링

### B. 스케일링 방향에 따른 구분

**1. 워크로드 스케일링**:
- **수평적 워크로드 스케일링**: 파드의 개수 증가/감소
- **수직적 워크로드 스케일링**: 파드에 할당된 리소스(CPU, 메모리) 증가/감소

**2. 클러스터 스케일링**:
- **수평적 클러스터 스케일링**: 클러스터에 노드 추가/제거
- **수직적 클러스터 스케일링**: 기존 노드의 리소스 증가/감소 (덜 일반적)

## 3. 스케일링 방식: 수동 vs 자동

### 수동 스케일링 방식

1. **수평적 클러스터 스케일링 (수동)**
    - 새 노드를 수동으로 프로비저닝
    - `kubeadm join` 명령어로 클러스터에 노드 추가
    
2. **수직적 클러스터 스케일링 (수동)**
    - 일반적이지 않은 접근법
    - 서버 중단이 필요하므로 권장되지 않음
    - 대신 더 높은 리소스를 가진 새 노드 추가 후 기존 노드 제거
    
3. **수평적 워크로드 스케일링 (수동)**
    - `kubectl scale` 명령어로 파드 수 조정
    ```bash
    kubectl scale deployment my-app --replicas=5
    ```
    
4. **수직적 워크로드 스케일링 (수동)**
    - `kubectl edit` 명령어로 디플로이먼트의 리소스 요청/제한 수정
    ```bash
    kubectl edit deployment my-app
    ```
    

### 자동 스케일링 메커니즘

쿠버네티스는 다양한 자동 스케일링 솔루션을 제공합니다:

1. **Cluster Autoscaler (CA)**
    - **목적**: 수평적 클러스터 스케일링 자동화
    - **기능**: 워크로드 요구사항에 따라 노드 수 자동 조정
    - **작동 방식**: 파드가 스케줄링되지 못할 때 노드 추가, 노드 활용도가 낮을 때 노드 제거
    
2. **Horizontal Pod Autoscaler (HPA)**
    - **목적**: 수평적 워크로드 스케일링 자동화
    - **기능**: 메트릭에 기반하여 파드 수 자동 조정
    - **작동 방식**: CPU, 메모리 또는 커스텀 메트릭 사용량에 따라 레플리카 수 조정
    
3. **Vertical Pod Autoscaler (VPA)**
    - **목적**: 수직적 워크로드 스케일링 자동화
    - **기능**: 파드의 리소스 요청/제한 자동 조정
    - **작동 방식**: 실제 리소스 사용량에 기반하여 컨테이너 리소스 할당량 조정

> 📝 **참고**: CKA 시험에서는 주로 HPA와 VPA에 중점을 둡니다.
## 4. 스케일링 유형 비교

### 워크로드 스케일링: HPA vs VPA

|특성|Horizontal Pod Autoscaler (HPA)|Vertical Pod Autoscaler (VPA)|
|---|---|---|
|**스케일링 방식**|파드 개수 증가/감소|파드 리소스 할당량 증가/감소|
|**중단 여부**|기존 파드 유지, 새 파드 추가/제거|기존 파드 재시작 필요 (일반적으로)|
|**트래픽 급증 대응**|빠른 대응 가능|파드 재시작으로 인한 지연|
|**최적 사용 사례**|웹 서버, API 서버, 마이크로서비스|데이터베이스, JVM 애플리케이션, AI/ML 워크로드|

### 클러스터 스케일링: 수동 vs Cluster Autoscaler

|특성|수동 클러스터 스케일링|Cluster Autoscaler|
|---|---|---|
|**자동화 수준**|관리자 개입 필요|완전 자동화|
|**반응 시간**|느림 (수동 작업)|빠름 (자동 감지)|
|**리소스 효율성**|낮음 (과잉/과소 프로비저닝 위험)|높음 (수요에 따른 조정)|
|**운영 오버헤드**|높음 (모니터링 및 수동 조정)|낮음 (설정 후 자동 운영)|

## 5. 스케일링 선택 가이드

### 상황별 최적 스케일링 전략

1. **웹 애플리케이션, API 서버**
    - 일반적으로 트래픽 변동이 심함
    - 권장: HPA + Cluster Autoscaler
    - 이유: 빠른 스케일 아웃과 무중단 확장 가능
    
2. **데이터베이스, 캐시 시스템**
    - 메모리와 CPU 요구사항이 높지만 인스턴스 수 증가는 복잡함
    - 권장: VPA
    - 이유: 개별 인스턴스 성능 최적화 필요
    
3. **배치 처리 작업**
    - 주기적으로 많은 리소스 필요
    - 권장: 작업별 HPA + Cluster Autoscaler
    - 이유: 필요 시 많은 노드와 파드 동시 활용
    
4. **개발/테스트 환경**
    - 사용 패턴이 불규칙하고 밤/주말에 활용도 낮음
    - 권장: Cluster Autoscaler
    - 이유: 사용하지 않는 시간에 비용 절감

### 다중 스케일링 전략 조합

복잡한 애플리케이션은 여러 스케일링 전략을 조합하여 사용할 수 있습니다:

- **프론트엔드**: HPA로 트래픽에 따른 빠른 수평 확장
- **백엔드 API**: HPA로 요청량에 따른 수평 확장
- **데이터베이스**: VPA로 리소스 사용량에 따른 수직 확장
- **전체 클러스터**: Cluster Autoscaler로 필요에 따른 노드 확장/축소

> ⚠️ **주의**: HPA와 VPA를 동일한 워크로드의 동일한 메트릭(CPU/메모리)에 대해 함께 사용하면 충돌이 발생할 수 있습니다. 다른 메트릭을 사용하여 조합하는 것이 좋습니다.

## 요약

- 쿠버네티스는 워크로드(파드)와 클러스터(노드) 모두에 대한 스케일링을 지원합니다.
- 수평적 스케일링은 인스턴스 수를 조정하고, 수직적 스케일링은 리소스 할당량을 조정합니다.
- 자동 스케일링 도구로는 HPA(수평적 파드), VPA(수직적 파드), Cluster Autoscaler(클러스터) 등이 있습니다.
- 애플리케이션 특성과 요구사항에 따라 적절한 스케일링 전략을 선택해야 합니다.
- 복잡한 시스템에서는 여러 스케일링 전략을 조합하여 사용하는 것이 효과적입니다.
## 2. 수평적 파드 오토스케일러 (HPA)

### HPA 개념 및 필요성

수평적 파드 오토스케일러(Horizontal Pod Autoscaler, HPA)는 워크로드의 리소스 사용량을 모니터링하고 파드의 개수를 자동으로 조정하는 쿠버네티스 리소스입니다.

**수동 스케일링의 한계**:

- 관리자가 지속적으로 리소스 사용량을 모니터링해야 함
- 스케일링을 위해 수동으로 명령어 실행 필요
- 갑작스러운 트래픽 증가에 신속하게 대응하기 어려움
- 사람의 개입으로 인한 지연 발생

> 💡 **HPA의 이점**: CPU, 메모리 또는 커스텀 메트릭에 기반하여 자동으로 워크로드를 스케일링하므로, 수동 개입 없이도 트래픽 변화에 효과적으로 대응할 수 있습니다.

### HPA 작동 방식

1. **메트릭 모니터링**: HPA는 지정된 메트릭(예: CPU 사용량)을 지속적으로 모니터링
2. **임계값 비교**: 현재 사용량을 설정된 임계값(예: CPU 50%)과 비교
3. **복제본 조정**: 사용량이 임계값을 초과하면 파드 수를 증가시키고, 낮아지면 감소시킴
4. **범위 제한**: 설정된 최소/최대 복제본 수 범위 내에서만 스케일링 수행

> ⚠️ **중요**: HPA가 작동하려면 클러스터에 metrics-server가 설치되어 있어야 합니다.

### HPA 구성 방법

#### 명령형(Imperative) 방식

```bash
kubectl autoscale deployment my-app --cpu-percent=50 --min=1 --max=10
```

- `--cpu-percent=50`: CPU 사용률 임계값 50%
- `--min=1`: 최소 파드 수 1개
- `--max=10`: 최대 파드 수 10개

#### 선언형(Declarative) 방식

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: my-app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: my-app
  minReplicas: 1
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 50
```

### HPA 상태 확인 및 관리

```bash
# HPA 상태 확인
kubectl get hpa

# HPA 상세 정보 확인
kubectl describe hpa my-app-hpa

# HPA 삭제
kubectl delete hpa my-app-hpa
```

**HPA 상태 확인 예시 출력**:

```
NAME         REFERENCE               TARGETS    MINPODS   MAXPODS   REPLICAS   AGE
my-app-hpa   Deployment/my-app      65%/50%    1         10        4          2m
```

- `TARGETS`: 현재 CPU 사용률/설정된 임계값
- `REPLICAS`: 현재 파드 수

### 다양한 메트릭 유형

HPA는 다양한 종류의 메트릭을 기반으로 스케일링할 수 있습니다:

1. **리소스 메트릭**:
    - CPU 사용률
    - 메모리 사용률
    
2. **커스텀 메트릭**:
    - 클러스터 내부 커스텀 메트릭 어댑터를 통한 내부 메트릭
    - 예: 애플리케이션별 메트릭, 요청/초(RPS) 등
    
3. **외부 메트릭**:
    - 클러스터 외부 메트릭 어댑터를 통한 외부 메트릭
    - 예: Datadog, Dynatrace 등의 모니터링 도구에서 제공하는 메트릭

## 3. 인플레이스 파드 리사이징 (In-Place Pod Resizing)

### 인플레이스 리사이징 개념

인플레이스 파드 리사이징은 파드를 재시작하지 않고도 리소스 요청과 제한을 조정할 수 있는 기능입니다.

**기존 방식의 한계**:

- 파드의 리소스 요청/제한을 변경하려면 기존 파드를 삭제하고 새 파드를 생성해야 함
- 이는 애플리케이션 중단을 초래하며, 특히 상태 유지(stateful) 워크로드에 문제가 됨
- 서비스 가용성 저하 및 데이터 손실 가능성 존재

> 💡 **인플레이스 리사이징의 이점**: 파드를 중단 없이 수직적으로 확장하거나 축소할 수 있어, 애플리케이션 가용성을 유지하면서 리소스 할당을 최적화할 수 있습니다.

### 기능 상태 및 활성화 방법

- **현재 상태**: 알파 기능 (Kubernetes v1.27+, 작성 시점 v1.32)
- **기본 설정**: 기본적으로 비활성화됨
- **활성화 방법**: `InPlacePodVerticalScaling` 기능 플래그를 `True`로 설정

```bash
# kube-apiserver 설정에 기능 플래그 추가
--feature-gates=InPlacePodVerticalScaling=true
```

### 리사이즈 정책 구성

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
  - name: nginx
    image: nginx
    resources:
      requests:
        cpu: 500m
        memory: 512Mi
      limits:
        cpu: 1
        memory: 1Gi
    resizePolicy:
    - resourceName: cpu
      restartPolicy: NotRequired
    - resourceName: memory
      restartPolicy: RestartContainer
```

**리사이즈 정책 옵션**:

- `resourceName`: 조정할 리소스 유형 (cpu, memory)
- `restartPolicy`: 리소스 변경 시 재시작 정책
    - `NotRequired`: 재시작 없이 변경 적용
    - `RestartContainer`: 컨테이너 재시작 필요

### 인플레이스 리사이징 사용 예시

기존 파드의 CPU 할당량을 500m에서 1000m으로 증가:

```bash
kubectl patch pod nginx -p '{"spec":{"containers":[{"name":"nginx","resources":{"requests":{"cpu":"1"},"limits":{"cpu":"1"}}}]}}'
```

이 경우 `resizePolicy`에 따라:

- CPU는 `NotRequired`로 설정되어 있으므로, 파드가 재시작되지 않고 CPU 자원이 1000m으로 증가
- 메모리는 변경되지 않았으므로 영향 없음

### 인플레이스 리사이징의 제한사항

1. **지원 리소스 제한**: 현재 CPU와 메모리 리소스만 지원
2. **QoS 클래스 변경 불가**: 파드의 QoS 클래스(Quality of Service) 변경 불가
3. **특수 컨테이너 제외**: Init 컨테이너와 임시(Ephemeral) 컨테이너는 리사이징 불가
4. **리소스 추가/제거 불가**: 이미 설정된 리소스 요청/제한만 수정 가능, 새로 추가/제거 불가
5. **메모리 축소 제한**: 컨테이너의 메모리 한도는 현재 사용량 아래로 축소 불가
6. **Windows 미지원**: Windows 파드는 현재 리사이징 지원하지 않음

> ⚠️ **주의**: 메모리 한도를 현재 사용량보다 낮게 설정하려고 하면, 리사이징 상태는 "진행 중"으로 유지되며 메모리 사용량이 원하는 한도 아래로 떨어질 때까지 완료되지 않습니다.

## 4. 수직적 파드 오토스케일러 (VPA) 개요

수직적 파드 오토스케일러(Vertical Pod Autoscaler, VPA)는 파드의 CPU 및 메모리 요청을 자동으로 조정하는 쿠버네티스 컴포넌트입니다.

**HPA와 VPA 비교**:

- HPA: 파드의 **개수**를 조정 (수평적 확장)
- VPA: 파드의 **리소스 할당량**을 조정 (수직적 확장)

> 📝 **참고**: VPA에 대한 자세한 내용은 별도의 강의에서 다루며, 인플레이스 리사이징과 연계하여 보다 효과적인 자동 수직 확장이 가능합니다.

## 요약 및 모범 사례

### 요약

1. **HPA**: 워크로드의 복제본 수를 자동으로 조정하여 수평적 확장
2. **인플레이스 리사이징**: 파드를 재시작하지 않고 리소스 할당량 조정
3. **VPA**: 파드의 리소스 요청/제한을 자동으로 조정하여 수직적 확장
- 인플레이스 리사이징은 파드를 재시작하지 않고 리소스를 변경하는 '메커니즘'이고, VPA는 이 메커니즘을 활용하는 자동화된 '오토스케일러'

### 오토스케일링 모범 사례

1. **메트릭 서버 설정**: HPA 및 VPA가 제대로 작동하려면 메트릭 서버가 필요
2. **적절한 임계값 설정**: 너무 민감하거나 둔감한 임계값 설정 피하기
3. **복합 메트릭 활용**: 단일 메트릭에만 의존하지 말고, 다양한 메트릭 조합 고려
4. **최소/최대 값 설정**: 리소스 낭비와 성능 저하 방지를 위한 적절한 범위 설정
5. **스케일링 이력 모니터링**: 스케일링 패턴을 분석하여 설정 최적화
6. **HPA와 VPA 함께 사용**: 워크로드 특성에 따라 두 오토스케일러를 적절히 조합