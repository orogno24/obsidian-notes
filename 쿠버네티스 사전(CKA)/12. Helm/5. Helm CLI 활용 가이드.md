### Helm 도움말 활용

- **기본 도움말**: `helm help` - 모든 사용 가능한 명령 목록 표시
- **하위 명령 도움말**: `helm [command] help` - 특정 명령에 대한 자세한 정보
    - 예: `helm repo help` - 저장소 관련 명령 설명
- **명령 매개변수**: 더 깊은 수준의 매개변수 정보 확인 가능
- **장점**: 인터넷 검색 없이 명령어 빠르게 확인 가능

## WordPress 웹사이트 배포 예시

### 차트 검색 방법

#### 1. 웹 인터페이스 사용

- **Artifact Hub 방문**: artifacthub.io 접속
- **품질 확인**: '공식' 또는 '인증된 게시자' 배지 확인
- **차트 세부 정보 확인**:
    - 설치 명령어
    - 사용 소프트웨어 구성 요소
    - 구성 가능한 중요 설정

#### 2. 명령줄 검색

- **검색 명령**: `helm search [hub|repo] [검색어]`
    - `hub`: Artifact Hub 전체 검색 (artifacthub.io)
    - `repo`: 추가된 특정 저장소 검색
- **예시**: `helm search hub wordpress`
- **결과**: WordPress 배포용 차트 목록과 앱 버전 표시

### 애플리케이션 배포 과정

1. **저장소 추가**:
    
    ```
    helm repo add bitnami https://charts.bitnami.com/bitnami
    ```
    - 로컬 Helm 설정에 차트 저장소 추가

2. **애플리케이션 설치**:
    
    ```
    helm install my-release bitnami/wordpress
    ```
    - `my-release`: 릴리스 이름
    - `bitnami/wordpress`: 차트 위치

3. **설치 후 정보**:
    - 설치 완료 후 사용 방법에 대한 유용한 정보 제공
    - 차트에 포함된 지침에서 생성되는 텍스트

## 릴리스 관리 명령어

### 릴리스 목록 확인

- **명령**: `helm list`
- **용도**:
    - 설치된 모든 릴리스 확인
    - 장기간 업데이트되지 않은 릴리스 식별

### 릴리스 제거

- **명령**: `helm uninstall [릴리스_이름]`
- **장점**: 모든 관련 쿠버네티스 객체를 한 번에 제거
    - 수동으로 여러 객체를 하나씩 삭제할 필요 없음

## 저장소 관리 명령어

### 저장소 관련 주요 명령

1. **저장소 추가**: `helm repo add [이름] [URL]`
    - 예: `helm repo add bitnami https://charts.bitnami.com/bitnami`
    
2. **저장소 목록 확인**: `helm repo list`
    - 추가된 모든 저장소 표시

3. **저장소 업데이트**: `helm repo update`
    - 로컬에 저장된 저장소 정보 갱신
    - Linux의 `sudo apt-get update`와 유사한 기능
    - 최신 차트 정보를 로컬로 가져옴

4. **저장소 제거**: `helm repo remove [이름]`
    - 더 이상 필요하지 않은 저장소 제거

## Helm의 주요 장점 요약

- **간편한 배포**: 복잡한 애플리케이션도 몇 가지 명령으로 배포 가능
- **통합 관리**: 애플리케이션의 모든 구성 요소를 하나의 단위로 관리
- **쉬운 제거**: 관련된 모든 리소스를 한 번에 제거 가능
- **직관적인 인터페이스**: 도움말 시스템으로 쉽게 명령어 학습 가능

---

## 활용 팁

- 항상 `helm repo update`를 실행하여 최신 차트 정보 유지
- 공식 또는 인증된 게시자의 차트를 우선적으로 사용
- `helm list`를 정기적으로 실행하여 클러스터의 릴리스 상태 확인
- 설치 후 표시되는 사용 안내 정보 참고하여 추가 설정 진행

Helm CLI를 통해 쿠버네티스 애플리케이션을 패키지 형태로 쉽게 관리할 수 있습니다. 이는 복잡한 애플리케이션 배포 과정을 크게 단순화하고, 일관된 방식으로 애플리케이션 라이프사이클을 관리할 수 있게 해줍니다.