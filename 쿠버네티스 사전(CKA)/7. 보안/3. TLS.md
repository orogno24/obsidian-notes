## 1. 인증서의 기본 개념
SSL/TLS 인증서는 네트워크 통신에서 두 당사자 간의 신뢰를 보장하는 데 사용됩니다.
### 인증서의 목적
- **암호화**: 통신 데이터를 암호화하여 도청 방지
- **인증**: 서버가 실제로 주장하는 대상인지 확인
- **무결성**: 전송 중 데이터 변조 방지

> 💡 **예시**: 온라인 뱅킹 애플리케이션 접속 시, 사용자의 자격 증명과 금융 데이터가 안전하게 전송되도록 보장합니다.

## 2. 암호화 방식

### 대칭 암호화(Symmetric Encryption)

대칭 암호화는 하나의 키를 사용하여 데이터를 암호화하고 복호화하는 방식입니다.

**작동 방식**:
1. 발신자가 키를 사용하여 메시지 암호화
2. 암호화된 메시지와 키를 수신자에게 전송
3. 수신자가 같은 키로 메시지 복호화

**단점**:
- 키를 안전하게 공유하는 것이 어려움
- 네트워크를 통해 키를 전송하면 중간자 공격에 취약
### 비대칭 암호화(Asymmetric Encryption)

비대칭 암호화는 두 개의 관련된 키(공개 키와 개인 키)를 사용합니다.

**작동 방식**:
1. 각 당사자는 공개 키와 개인 키 쌍을 생성
2. 공개 키는 누구에게나 공유 가능, 개인 키는 비밀로 유지
3. 공개 키로 암호화된 데이터는 오직 해당 개인 키로만 복호화 가능
4. 개인 키로 암호화된 데이터는 해당 공개 키로만 복호화 가능

**이점**:
- 키 교환 문제 해결
- 더 강력한 보안 제공
## 3. 실제 적용 사례

### SSH 접속 보안

SSH 접속 보안을 위한 공개 키/개인 키 사용 방법:

1. **키 쌍 생성**:
    
    ```bash
    ssh-keygen
    ```
    - `id_rsa`: 개인 키(private key)
    - `id_rsa.pub`: 공개 키(public key)
    
2. **서버 설정**:
    - 공개 키를 서버의 `~/.ssh/authorized_keys` 파일에 추가
    - 이제 서버는 해당 공개 키와 쌍을 이루는 개인 키를 가진 사용자만 접근 허용
    
3. **SSH 접속**:
    
    ```bash
    ssh -i /path/to/private_key user@server
    ```
    
4. **다중 서버 접근**:
    - 동일한 공개 키를 여러 서버에 배포 가능
    - 하나의 개인 키로 여러 서버에 접근 가능

### 웹 서버 HTTPS 보안

웹 사이트에서 HTTPS를 구현하는 방법:

1. **하이브리드 암호화**:
    - 초기 연결: 비대칭 암호화로 안전한 채널 수립
    - 지속적 통신: 대칭 암호화로 효율적인 데이터 전송
    
2. **초기 연결 과정**:
    - 사용자가 HTTPS 웹사이트 접속
    - 서버가 인증서(공개 키 포함)를 클라이언트에 전송
    - 클라이언트(브라우저)가 인증서 유효성 검증
    - 클라이언트가 대칭 키(세션 키) 생성
    - 클라이언트가 서버의 공개 키로 세션 키 암호화하여 전송
    - 서버가 개인 키로 메시지 복호화하여 세션 키 획득
    - 이후 통신은 세션 키를 사용한 대칭 암호화로 진행

## 4. 인증서와 신뢰

### 인증서 구성 요소

디지털 인증서에는 다음과 같은 정보가 포함됩니다:

- **주체(Subject)**: 인증서 소유자 정보(도메인명 등)
- **발행자(Issuer)**: 인증서를 서명한 인증 기관(CA) 정보
- **유효 기간**: 인증서 유효 시작일과 만료일
- **공개 키**: 인증서 소유자의 공개 키
- **디지털 서명**: CA의 개인 키로 생성된 서명
- **주체 대체 이름(SAN)**: 추가 도메인명이나 IP 주소

### 자체 서명 인증서 vs CA 서명 인증서

**자체 서명 인증서**:

- 직접 생성하고 서명한 인증서
- 제3자의 검증 없음
- 브라우저가 신뢰하지 않음(경고 표시)
- 테스트 환경이나 내부 개발용으로 적합

**CA 서명 인증서**:

- 신뢰할 수 있는 인증 기관(CA)이 서명한 인증서
- 신원 검증 과정 포함
- 브라우저가 신뢰함(경고 없음)
- 프로덕션 환경에 적합

### 인증서 서명 요청(CSR) 프로세스

CA로부터 서명된 인증서를 얻는 과정:

1. **키 쌍 생성**:
    
    ```bash
    openssl genrsa -out myserver.key 2048
    ```
    
2. **CSR 생성**:
    
    ```bash
    openssl req -new -key myserver.key -out myserver.csr
    ```
    - 이 과정에서 조직 정보와 도메인명 등을 입력
    
3. **CA에 CSR 제출**:
    - CSR 파일을 선택한 CA에 제출
    - CA가 신원 검증 수행(도메인 소유권 확인 등)
    
4. **서명된 인증서 수령**:
    - 검증 완료 후 CA가 서명된 인증서 발급
    - 인증서를 웹 서버에 설치

## 5. 인증서 신뢰 체인

브라우저가 서버 인증서를 검증하는 과정:

1. **인증서 확인**: 서버로부터 받은 인증서 검토
2. **발행자 확인**: 인증서 발행자(CA) 확인
3. **서명 검증**: CA의 공개 키로 인증서 서명 검증
4. **신뢰성 확인**: CA가 브라우저의 신뢰할 수 있는 CA 목록에 있는지 확인
5. **유효성 검증**: 인증서가 만료되지 않았고 도메인명이 일치하는지 확인

### 루트 CA와 중간 CA

**루트 CA**
- 인증서 신뢰 체인의 최상위 엔티티
- 자체 서명 인증서 사용
- 브라우저와 OS에 기본 내장됨

**중간 CA**
- 루트 CA에 의해 인증됨
- 실제 최종 엔티티 인증서 발급
- 루트 CA의 보안 강화를 위해 사용

**인증서 체인**:
- 최종 엔티티 인증서 → 중간 CA 인증서 → 루트 CA 인증서
- 전체 체인이 유효해야 인증서가 신뢰됨

### 공개 CA vs 사설 CA

**공개 CA**:
- 인터넷에 공개된 웹사이트용
- Symantec, DigiCert, Comodo, GlobalSign 등
- 브라우저에 기본 내장되어 있음

**사설 CA**:
- 조직 내부용
- 내부 애플리케이션, 인트라넷 등에 사용
- 조직에서 직접 설정하고 관리
- 사용자 브라우저에 수동으로 CA 인증서 설치 필요

## 6. 클라이언트 인증서

서버가 클라이언트의 신원을 확인하는 방법:

### 서버-클라이언트 상호 인증

1. **서버 인증**: 서버가 클라이언트에게 인증서 제공
2. **클라이언트 인증**: 클라이언트도 서버에게 인증서 제공
3. **양방향 검증**: 양쪽 모두 상대방의 신원 확인

### 클라이언트 인증서 사용 사례

- **기업 VPN**: 회사 네트워크 접근 시 사용자 인증
- **API 접근 제어**: 서비스 간 통신 인증
- **내부 시스템 접근**: 높은 보안이 필요한 내부 시스템
- **금융 거래**: 특정 고보안 금융 거래 시스템

> 📝 **참고**: 웹사이트에서 클라이언트 인증서는 일반적으로 구현되지 않음 (사용자 경험 저하)

## 7. PKI(Public Key Infrastructure)

PKI는 디지털 인증서를 생성, 관리, 배포, 사용하기 위한 전체 시스템과 정책을 의미합니다.

### PKI 구성 요소

- **인증 기관(CA)**: 인증서 발급 및 서명
- **등록 기관(RA)**: 사용자 신원 확인 및 인증서 요청 처리
- **인증서 저장소**: 발급된 인증서 저장
- **인증서 해지 목록(CRL)**: 해지된 인증서 목록
- **인증서 정책**: 인증서 사용 및 관리 규칙

### PKI 작동 방식
1. 사용자/서버가 키 쌍 생성
2. 사용자/서버가 CSR 생성 및 RA/CA에 제출
3. RA가 신원 확인
4. CA가 인증서 서명 및 발급
5. 인증서가 저장소에 저장되고 소유자에게 전달
6. 인증서를 사용하여 보안 통신 수행

## 8. 명명 규칙 및 파일 형식

### 파일 확장자

- **인증서(공개 키 포함)**:
    - `.crt`, `.pem`: 인증서 파일
    - `server.crt`, `server.pem`: 서버 인증서
    - `client.crt`, `client.pem`: 클라이언트 인증서
    
- **개인 키**:
    - `.key`, `-key.pem`: 개인 키 파일
    - `server.key`, `server-key.pem`: 서버 개인 키
    - `client.key`, `client-key.pem`: 클라이언트 개인 키

### 인증서 형식

- **PEM(Privacy Enhanced Mail)**: 가장 일반적인 형식, Base64 인코딩, 텍스트 형식
- **DER(Distinguished Encoding Rules)**: 바이너리 형식
- **PKCS#12(.p12, .pfx)**: 인증서와 개인 키를 하나의 암호화된 파일로 저장

> 💡 **팁**: 일반적으로 "key"라는 단어가 파일 이름에 들어있으면 개인 키, 그렇지 않으면 인증서(공개 키)입니다.

## 요약

- **인증서**는 네트워크 통신에서 **암호화**, **인증**, **무결성**을 제공합니다.
- **대칭 암호화**는 하나의 키를 사용하지만, 키 공유 문제가 있습니다.
- **비대칭 암호화**는 공개 키/개인 키 쌍을 사용하여 더 안전한 통신을 제공합니다.
- **SSL/TLS**는 초기 연결에 비대칭 암호화를, 이후 통신에 대칭 암호화를 사용합니다.
- **인증서**는 서버의 신원을 증명하며, CA에 의해 서명됩니다.
- **인증서 체인**은 최종 엔티티 인증서부터 루트 CA까지 신뢰 관계를 형성합니다.
- **클라이언트 인증서**는 클라이언트의 신원을 서버에 증명합니다.
- **PKI**는 디지털 인증서의 생성, 관리, 배포, 사용을 위한 전체 인프라입니다.