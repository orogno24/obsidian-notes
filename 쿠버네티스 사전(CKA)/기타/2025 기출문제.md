## 1. Gateway TLS 설정

  
- GatewayClass

```yaml

apiVersion: gateway.networking.k8s.io/v1

kind: GatewayClass

metadata:

  name: my-gateway-class

spec:

  controllerName: example.com/gateway-controller

```

  

- Gateway

```yaml

apiVersion: gateway.networking.k8s.io/v1

kind: Gateway

metadata:

  name: my-gateway

  namespace: <namespace>

spec:

  gatewayClassName: my-gateway-class

  listeners:

    - name: https

      protocol: HTTPS

      port: 443

      hostname: example.com

      tls:

        mode: Terminate

        certificateRefs:

          - name: tls-secret

      allowedRoutes:

        namespaces:

          from: Same

```

  

- HTTPRoute

```yaml

apiVersion: gateway.networking.k8s.io/v1

kind: HTTPRoute

metadata:

  name: my-httproute

  namespace: <namespace>

spec:

  parentRefs:

    - name: my-gateway

      sectionName: https

  hostnames:

    - example.com

  rules:

    - matches:

        - path:

            type: PathPrefix

            value: /

      backendRefs:

        - name: my-service

          port: 80

```

  
  

## 2. Network Policy

  

- 가장 제한적으로 요구를 충족시키는 YAML 선택

```yaml

apiVersion: networking.k8s.io/v1

kind: NetworkPolicy

metadata:

  name: test-network-policy

  namespace: default

spec:

  podSelector: # 적용파드

    matchLabels:

      role: db

  policyTypes:

  - Ingress

  - Egress

  ingress:

  - from:

    - ipBlock: # IP 조건

        cidr: 172.17.0.0/16

        except:

        - 172.17.1.0/24

    - namespaceSelector: # 네임스페이스 조건

        matchLabels:

          project: myproject

    - podSelector: # 파드 조건

        matchLabels:

          role: frontend

    ports: # 포트 조건

    - protocol: TCP

      port: 6379

  egress: [] # 모두 차단

```

  
  

## 3. Kubelet 고치기

  

- 문제 확인 명령어

```sh

$ k get node

$ sudo -i

$ ps aux | grep kubelet

$ service kubelet status

$ journalctl -u kubelet

$ /usr/local/bin/kubelet

$ whereis kubelet

$ which kubelet

$ cat /var/log/syslog | grep kubelet

$ vim /usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf

$ systemctl daemon-reload

$ service kubelet restart

```

  

- /usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf의 kubelet 경로 문제

- /var/lib/kubelet/config.yaml의 오타 문제

- /var/lib/kubelet/pki 인증서 만료 문제 > 인증서 삭제 후 kubelet 재시작

- kubelet 포트 중복

- config파일 또는 인증서 권한, 소유권 문제

  
  

## 4. Resouce 관리

  

- ResourceQuota 초과

- Node 자원 부족

  

```yaml

apiVersion: v1

  kind: ResourceQuota

  metadata:

    name: pods-low

  spec:

    hard:

      cpu: "5"

      memory: "10Gi"

      pods: "10"

    scopeSelector:

      matchExpressions:

      - operator: In

        scopeName: PriorityClass

        values: ["low"]

```

  
  

## 5. Helm 으로 ArgoCD설치

  

```yaml

# 1. 저장소 추가

helm repo add argo https://argoproj.github.io/argo-helm

helm repo update

  

# 2. 네임스페이스 생성

kubectl create namespace argocd

  

# 3. 설치 (예시: 버전 7.7.3, CRD 설치 금지)

helm install argocd argo/argo-cd \

  --namespace argocd \

  --version 7.7.3 \

  --set crds.install=false

```

  

## 6. PVC Bound 하기

  

- PV

```yaml

apiVersion: v1

kind: PersistentVolume

metadata:

  name: manual-pv-cka

spec:

  capacity:

    storage: 1Gi

  accessModes:

    - ReadWriteOnce

  persistentVolumeReclaimPolicy: Retain

  hostPath:

    path: /mnt/data

```

  

- PVC

```yaml

apiVersion: v1

kind: PersistentVolumeClaim

metadata:

  name: manual-pvc-cka

spec:

  accessModes:

    - ReadWriteOnce

  resources:

    requests:

      storage: 500Mi

```

  

- PV - Node Affinity 문제(고급)

```yaml

apiVersion: v1

kind: PersistentVolume

metadata:

  name: node-affinity-pv

spec:

  nodeAffinity:

    required:

      nodeSelectorTerms:

      - matchExpressions:

        - key: kubernetes.io/hostname

          operator: In

          values:

          - node01  # 반드시 해당 노드 존재 확인

  hostPath:

    path: /opt/data

```

  

- Deployment

```yaml

# Deployment 일부...

      containers:

        - name: my-app

          image: nginx

          volumeMounts:

            - mountPath: /data

              name: data-volume

      volumes:

        - name: data-volume

          persistentVolumeClaim:

            claimName: manual-pvc-cka

```

  

## 7. YAML 출력

  

- CRD 목록

```bs

$ kubectl get crd -o yaml > ~/resources.yaml

$ kubectl get crd | grep -i cert-manager > ~/resources.yaml

```

  

- 설정값

```sh

$ kubectl explain certificates.spec.subject > ~/subject.yaml

$ kubectl get crd certificates.cert-manager.io -o jsonpath='{.spec.versions[*].schema.openAPIV3Schema.properties.spec.properties.subject}' > ~/subject.json

```

  
  

## 8. Kubectl로 expose

  

```sh

$ kubectl expose deployment my-nginx --type=NodePort --port=80

```

  
  
  

## 9. Sidecar Container

  

```yaml

apiVersion: apps/v1

kind: Deployment

metadata:

  name: synergy-leverager

spec:

  replicas: 1

  selector:

    matchLabels:

      app: synergy-leverager

  template:

    metadata:

      labels:

        app: synergy-leverager

    spec:

      containers:

        - name: app

          image: nginx:latest

          volumeMounts:

            - name: log-volume

              mountPath: /var/log

        - name: sidecar

          image: busybox:stable

          command: ["/bin/sh", "-c", "tail -n+1 -f /var/log/synergy-leverager.log"]

          volumeMounts:

            - name: log-volume

              mountPath: /var/log

      volumes:

        - name: log-volume

          emptyDir: {}

```

  

- 반드시 로그 확인할 것

  

## 10. Priority Class 적용

  

- Priority Class 설정

```yaml

apiVersion: scheduling.k8s.io/v1

kind: PriorityClass

metadata:

  name: high-priority

value: 999

description: "User high priority"

globalDefault: false

```

  

- Priority Class 적용

```yaml

spec:

  template:

    spec:

      priorityClassName: high-priority

```

  

- 반드시 재시작 할 것

```sh

$ kubectl -n priority rollout restart deployment busybox-logger

```

  
  

## 11. HPA 설정

  

```yaml

apiVersion: autoscaling/v2

kind: HorizontalPodAutoscaler

metadata:

  name: apache-server

  namespace: autoscale

spec:

  scaleTargetRef:

    apiVersion: apps/v1

    kind: Deployment

    name: apache-server

  minReplicas: 1

  maxReplicas: 4

  metrics:

    - type: Resource

      resource:

        name: cpu

        target:

          type: Utilization

          averageUtilization: 50

  behavior:

    scaleDown:

      stabilizationWindowSeconds: 30

```

  
  

## 12. CNI 설치

  

#### 1) Calico

- 매니페스트로 설치 ( NetworkPolicy가 필요한 경우 반드시 create )

```sh

$ kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.29.2/manifests/tigera-operator.yaml

  

$ kubectl get pods -n calico-system

```

  

#### 2) Flannel

- 매니페스트로 설치 ( NetworkPolicy가 필요 없는 경우 apply )

```yaml

$ kubectl apply -f https://github.com/flannel-io/flannel/releases/download/v0.26.1/kube-flannel.yml

  

$ kubectl get pods -n kube-flannel

```

  

- 반드시 통신 테스트

```sh

$ kubectl run test1 --image=busybox --restart=Never -- sleep 3600

$ kubectl run test2 --image=busybox --restart=Never -- sleep 3600

$ kubectl exec test1 -- ping -c 4 test2

```

  
  

## 13. ConfigMap 설정

  

- 직접 수정

```sh

$ kubectl edit configmap <configmap-name> -n <namespace>

```

  

- 수정 적용

```sh

$ kubectl rollout restart deployment <deployment-name> -n <namespace>

```

  

- 반영 확인

```sh

$ kubectl exec -it <pod-name> -n <namespace> -- sh

# 환경변수 확인

echo $<ENV_VAR_NAME>

# 파일로 마운트된 경우

cat /<mount-path>/<key>

```

  
  

## 14. cri-docker 설치

  

- dpkg 설치

```sh

$ sudo dpkg -i ~/cri-dockerd_0.3.9.3-0.ubuntu-focal_amd64.deb

```

  

- 서비스 활성화 및 실행

```sh

$ sudo systemctl enable --now cri-docker

```

  

- 상태 확인

```sh

$ sudo systemctl status cri-docker

```

  

- 설정

```sh

$ cat <<EOF | sudo tee /etc/sysctl.d/k8s.conf

net.bridge.bridge-nf-call-iptables = 1

net.ipv6.conf.all.forwarding = 1

net.ipv4.ip_forward = 1

EOF

  

$ sudo sysctl --system

```

  
  

## 15. StorageClass 설정

  

```yaml

apiVersion: storage.k8s.io/v1

kind: StorageClass

metadata:

  name: local-path

  annotations:

    storageclass.kubernetes.io/is-default-class: "true"

provisioner: rancher.io/local-path

volumeBindingMode: WaitForFirstConsumer

```

  
  

## 16. StatefulSet 및 Headless Service

  

- StatefulSet

```yaml

apiVersion: apps/v1

kind: StatefulSet

metadata:

  name: web

spec:

  serviceName: web

  replicas: 3

  selector:

    matchLabels:

      app: web

  template:

    metadata:

      labels:

        app: web

    spec:

      containers:

        - name: nginx

          image: nginx

          ports:

            - containerPort: 80

```

  

- Service

```yaml

apiVersion: v1

kind: Service

metadata:

  name: web

spec:

  clusterIP: None

  selector:

    app: web

  ports:

    - port: 80

      name: http

```

  
  

## 17. Node Affinity

  

```yaml

apiVersion: v1

kind: Pod

metadata:

  name: affinity-pod

spec:

  affinity:

    nodeAffinity:

      requiredDuringSchedulingIgnoredDuringExecution:

        nodeSelectorTerms:

          - matchExpressions:

              - key: app

                operator: In

                values:

                  - frontend

  containers:

    - name: nginx

      image: nginx

```

  
  

## 18. Taints & Tolerations

  

- taints 추가

```sh

$ kubectl taint nodes node1 dedicated=dedicated:NoSchedule

```

  

- Pod 적용

```yaml

apiVersion: v1

kind: Pod

metadata:

  name: toleration-pod

spec:

  tolerations:

    - key: "dedicated"

      operator: "Equal"

      value: "dedicated"

      effect: "NoSchedule"

  containers:

    - name: nginx

      image: nginx

```

  
  

## 19. Pod Security 및 Admission Control

  

- `restricted` Pod Security Standard를 네임스페이스 `secure-ns`에 적용

```yaml

$ kubectl label namespace secure-ns pod-security.kubernetes.io/enforce=restricted

```

  
  

## 20. DaemonSet 생성

  

```yaml

apiVersion: apps/v1

kind: DaemonSet

metadata:

  name: fluentd

spec:

  selector:

    matchLabels:

      name: fluentd

  template:

    metadata:

      labels:

        name: fluentd

    spec:

      containers:

        - name: fluentd

          image: fluent/fluentd

```

  

## 21. CoreDNS 트러블슈팅

  

```sh

$ kubectl -n kube-system logs -l k8s-app=kube-dns

$ kubectl -n kube-system edit configmap coredns

# (예: 잘못된 forward 주소 수정)

$ kubectl -n kube-system rollout restart deployment coredns

```

  

## 22. 기본 네임스페이스 설정

  

```sh

$ kubectl create namespace dev

$ kubectl config set-context --current --namespace=dev

```

  

## 23. Static Pod

  

```yaml

# /etc/kubernetes/manifests/static-nginx.yaml

apiVersion: v1

kind: Pod

metadata:

  name: static-nginx

spec:

  containers:

    - name: nginx

      image: nginx

```

  

## 24. etcd 백업 및 복원

  

- 백업

```sh

$ ETCDCTL_API=3 etcdctl snapshot save /backup/etcd-backup.db \

  --endpoints=https://127.0.0.1:2379 \

  --cacert=/etc/kubernetes/pki/etcd/ca.crt \

  --cert=/etc/kubernetes/pki/etcd/server.crt \

  --key=/etc/kubernetes/pki/etcd/server.key

```

  
  

## 25. kustomize

  

```text

my-kustomize/

├── base/

│   ├── deployment.yaml

│   ├── service.yaml

│   └── kustomization.yaml

└── overlays/

    └── prod/

        ├── kustomization.yaml

        └── deployment-patch.yaml

```

  

- base/kustomization.yaml

```yaml

apiVersion: kustomize.config.k8s.io/v1beta1

kind: Kustomization

resources:

  - deployment.yaml

  - service.yaml

```

  

- overlays/prod/deployment-patch.yaml

```yaml

apiVersion: apps/v1

kind: Deployment

metadata:

  name: nginx

spec:

  replicas: 3

```

  

- overlays/prod/kustomization.yaml

```yaml

apiVersion: kustomize.config.k8s.io/v1beta1

kind: Kustomization

resources:

  - ../../base

namespace: prod

namePrefix: prod-

commonLabels:

  env: prod

patchesStrategicMerge:

  - deployment-patch.yaml

```

  

- 적용

```sh

$ kubectl kustomize overlays/prod > /root/final.yaml

  

$ kubectl apply -k overlays/prod

```