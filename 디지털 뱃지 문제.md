**Pod가 다음과 같은 리소스 요구사항을 가지고 있을 때, 어떤 노드에 스케줄링될 수 있는가?**

```yaml
resources:
  requests:
    memory: "256Mi"
    cpu: "500m"
  limits:
    memory: "512Mi"
    cpu: "1"
```

A) 남은 리소스가 memory: 200Mi, cpu: 400m인 노드  
B) 남은 리소스가 memory: 300Mi, cpu: 600m인 노드  
C) 남은 리소스가 memory: 256Mi, cpu: 400m인 노드  
D) 남은 리소스가 memory: 600Mi, cpu: 300m인 노드

**정답:** B (requests 기준으로 스케줄링되므로 memory 256Mi, cpu 500m 이상 필요)

---

**Kubernetes에서 Rolling Update 중 다음 설정의 의미는?**

```yaml
strategy:
  rollingUpdate:
    maxSurge: 25%
    maxUnavailable: 25%
```

A) 최대 25%의 Pod만 동시에 업데이트 가능  
B) 전체 Pod의 125%까지 일시적으로 실행 가능하고, 75% 이상은 항상 가용해야 함  
C) 25%의 Pod가 실패해도 업데이트 계속 진행  
D) 새로운 Pod는 기존 Pod의 25%만 생성 가능

**정답:** B (최대 125%까지 Pod 실행 가능, 최소 75%는 유지)

---

**etcd의 RAFT 합의 알고리즘에서 클러스터가 정상 작동하기 위한 최소 노드 수는?**

A) 전체 노드의 과반수 이상  
B) 전체 노드의 1/3 이상  
C) 최소 2개 노드  
D) 모든 노드가 필요

**정답:** A (과반수 이상 필요 - 3개면 2개, 5개면 3개)

---

**Service Mesh에서 Sidecar Proxy가 수행하지 않는 기능은?**

A) 서킷 브레이커  
B) 분산 트레이싱  
C) 컨테이너 이미지 빌드  
D) mTLS 인증

**정답:** C (Sidecar Proxy는 네트워크 트래픽 관리, 이미지 빌드는 CI/CD 영역)

---

**NetworkPolicy에서 다음 설정이 허용하는 트래픽은?**

```yaml
spec:
  podSelector:
    matchLabels:
      app: backend
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: frontend
    - podSelector:
        matchLabels:
          role: api
    ports:
    - port: 8080
```

A) frontend 네임스페이스의 모든 Pod와 role=api 레이블을 가진 Pod에서 오는 8080 포트 트래픽  
B) frontend 네임스페이스에 있으면서 role=api 레이블을 가진 Pod에서 오는 8080 포트 트래픽  
C) frontend 네임스페이스 또는 role=api 레이블 중 하나만 만족해도 8080 포트 접근 가능  
D) 모든 네임스페이스의 role=api Pod만 8080 포트 접근 가능

**정답:** A (from 아래의 조건들은 OR 관계)

---

## **쿠버네티스 (Kubernetes) 예상 문제**

**다음 중 Kubernetes의 `Deployment` 리소스에 대한 설명으로 옳지 않은 것은?**  
A. 롤링 업데이트를 통해 무중단 배포가 가능하다  
B. ReplicaSet을 자동으로 생성하고 관리한다  
C. 특정 시점의 상태로 롤백이 가능하다  
D. 상태 유지가 필요한 애플리케이션에 적합하다

**정답:** D (상태 유지 앱에는 StatefulSet 사용)

---

**`kubectl apply -f app.yaml` 명령을 실행했을 때 발생할 수 있는 상황이 아닌 것은?**  
A. 리소스가 생성된다  
B. 리소스가 삭제된다  
C. 리소스가 업데이트된다  
D. 리소스의 annotation이 수정된다

**정답:** B (apply는 삭제하지 않음)

---

**다음 중 Kubernetes에서 네트워크 정책(NetworkPolicy)와 가장 관련 있는 설명은?**  
A. 파드 간 통신을 암호화한다  
B. 파드의 CPU 리소스를 제한한다  
C. 파드 간 트래픽을 허용/차단하는 규칙을 정의한다  
D. 외부 로드밸런서를 구성한다

**정답:** C

---

**다음 중 `ConfigMap`과 `Secret`의 차이에 대한 설명으로 가장 적절한 것은?**  
A. 둘 다 반드시 base64로 인코딩해야 한다  
B. ConfigMap은 etcd에 저장되지 않는다  
C. Secret은 민감 정보를 저장하며 인코딩 처리가 된다  
D. ConfigMap은 컨테이너 환경변수로 사용할 수 없다

**정답:** C

---

**다음 중 `Horizontal Pod Autoscaler(HPA)`를 설정할 때 반드시 필요한 조건은?**  
A. Pod이 Deployment로 생성되어 있어야 한다  
B. Pod이 메모리를 100% 이상 사용해야 한다  
C. 대상에 메트릭 서버가 연결되어 있어야 한다  
D. HPA는 클러스터 전체에 자동으로 적용된다

**정답:** C

---

## **데브옵스 (DevOps) 예상 문제**

**다음 중 CI/CD 파이프라인에서 `artifact repository`의 역할로 가장 적절한 것은?**  
A. 테스트 자동화를 수행한다  
B. 빌드된 바이너리 결과물을 저장한다  
C. 소스 코드를 컴파일한다  
D. 배포된 로그를 수집한다

**정답:** B

---

**GitOps에서 핵심 원칙이 아닌 것은?**  
A. 인프라를 코드로 관리한다  
B. 상태 관리를 Git이 책임진다  
C. 배포는 수동으로 수행한다  
D. 선언적 구성(Declarative Config)을 사용한다

**정답:** C

---

**다음 중 DevOps 도구와 용도 매칭이 올바르지 않은 것은?**  
A. Terraform - 인프라 프로비저닝  
B. Prometheus - 모니터링  
C. Jenkins - CI/CD  
D. Ansible - 컨테이너 오케스트레이션

**정답:** D (Ansible은 구성 관리 도구)

---

**다음 중 블루-그린 배포 전략의 장점은 무엇인가?**  
A. 테스트 환경을 완전히 분리할 수 있다  
B. Canary 배포보다 빠르다  
C. 모든 트래픽을 동시에 새 버전으로 보낸다  
D. 롤백이 불가능하다

**정답:** A

---

**DevOps 문화에서 "Shift Left"의 의미는 무엇인가?**  
A. 배포를 나중으로 미룬다  
B. 테스트와 보안을 개발 초기 단계에 적용한다  
C. 배포 주기를 길게 한다  
D. 릴리즈 전에 QA 팀의 승인만 필요하다

**정답:** B

---

#### 🐳 쿠버네티스 – 6문제

1. **[중상]** Kubernetes v1.31에서 **Stable(GA)** 단계로 승격된 기능은?  
    A. Ephemeral Containers 기본 활성화  
    B. AppArmor 프로필 지정 지원  
    C. Volume Group Snapshots  
    D. IngressClass Parameters
    
2. **[어려움]** v1.31 릴리스에서 ‘Externalization’의 일환으로 **완전히 제거**된 코드 범주는?  
    A. In‑tree 클라우드 프로바이더 코드  
    B. CSR API v1alpha1  
    C. kube‑proxy userspace 모드  
    D. HostPath 볼륨 플러그인
    
3. **[중]** v1.31에서 **Alpha**로 처음 도입된 _Pod‑level Resource Limits_에 대한 설명으로 **옳지 않은** 것은?  
    A. Pod 전체에 CPU/메모리 한도를 지정한다.  
    B. 컨테이너별 리소스 제한만 허용한다.  
    C. 보안·운영 효율성을 모두 높인다.  
    D. 아직 Stable 기능이 아니다.
    
4. **[중]** v1.31에서 _Maintenance Mode_로 전환된 항목은?  
    A. cgroup v2 지원  
    B. cgroup v1 지원  
    C. IPv6 Dual‑Stack  
    D. Sidecar containers
    
5. **[어려움]** ‘Streaming Transitions from SPDY to WebSockets’ 개선이 적용되는 경로는?  
    A. kubelet ↔ 컨테이너 런타임 gRPC  
    B. `kubectl exec/attach/port‑forward`  
    C. API Server Admission Webhook  
    D. CSI Node Driver Registrar
    
6. **[중]** v1.31에서 Jobs API에 **GA로 승격**된 기능은?  
    A. JobSet  
    B. PodFailurePolicy  
    C. WorkloadPriorityClass  
    D. Suspend‑Job
    

#### ⚙️ 데브옵스 – 6문제

7. **[중]** 2025 DevOps 트렌드 ‘AI‑driven DevOps’의 **핵심 이점이 아닌** 것은?  
    A. 예측 분석으로 사전 장애 예방  
    B. 셀프‑힐링 시스템 구현  
    C. 수동 릴리스 승인 절차 확대  
    D. 자동 생성 테스트 케이스
    
8. **[중상]** _Shift‑left Security_에서 보안 활동이 이동하는 위치는?  
    A. 배포 후 운영 단계  
    B. CI/CD 초기(코딩) 단계  
    C. 네트워크 경계 방어층  
    D. 로그 분석·모니터링 단계
    
9. **[어려움]** TechRadar(2025) 기사에 따른 DevOps‑MLOps 통합 **주요 동기가 아닌** 것은?  
    A. 중복 도구·인프라 비용 절감  
    B. ML 모델을 테스트·보안 스캔에서 제외  
    C. 팀 간 사일로 해소  
    D. ML 모델을 표준 SW 아티팩트로 취급
    
10. **[중]** Atlassian이 제시한 DevOps 베스트 프랙티스에 **포함되지 않는** 것은?  
    A. 자동화·모니터링  
    B. 지속적인 피드백  
    C. 워터폴 기반 프로젝트 관리  
    D. CI/CD의 시프트‑레프트
    
11. **[중상]** ‘Green DevOps’ 설명 중 **틀린** 것은?  
    A. ESG 목표 달성을 위한 탄소 배출 고려  
    B. 컨테이너로 리소스 활용도 향상  
    C. 지속 가능성 KPI를 DevOps 워크플로에 통합  
    D. 최대한 많은 리소스를 선점해 예비 용량 확보
    
12. **[어려움]** GitOps가 전통적 DevOps 대비 제공하는 **주요 장점**은?  
    A. 인프라 변경의 단일 진실 소스 확보  
    B. 수동 배포 승인 의존  
    C. 상태 불일치 무시  
    D. 형상 관리 없이 동일 환경 보장
    

---

### ✅ 정답 & 해설

|#|정답|해설 요약|
|---|---|---|
|1|**B**|AppArmor 프로필 지정이 v1.31에서 Stable로 승격([Sysdig](https://sysdig.com/blog/whats-new-kubernetes-1-31/ "Kubernetes 1.31 - What’s new? \| Sysdig"))|
|2|**A**|v1.31에서 모든 in‑tree 클라우드 프로바이더 코드 제거로 벤더 중립성 강화([Sysdig](https://sysdig.com/blog/whats-new-kubernetes-1-31/ "Kubernetes 1.31 - What’s new? \| Sysdig"))|
|3|**B**|Pod‑level Resource Limits는 **Pod 단위** 한도를 추가하므로 ‘컨테이너별만 허용’은 오답([Sysdig](https://sysdig.com/blog/whats-new-kubernetes-1-31/ "Kubernetes 1.31 - What’s new? \| Sysdig"))|
|4|**B**|cgroup v1 지원이 Maintenance Mode로 전환되어 향후 v2 권장([Kubernetes](https://kubernetes.io/blog/2024/07/19/kubernetes-1-31-upcoming-changes/?utm_source=chatgpt.com "Kubernetes Removals and Major Changes In v1.31"))|
|5|**B**|`kubectl exec/attach/port‑forward` 경로가 SPDY→WebSockets로 전환해 안정성 향상([Kubernetes](https://kubernetes.io/blog/2024/08/13/kubernetes-v1-31-release/?utm_source=chatgpt.com "Kubernetes v1.31: Elli"))|
|6|**B**|Jobs API의 PodFailurePolicy가 GA 단계로 졸업([Kubernetes](https://kubernetes.io/blog/2024/08/13/kubernetes-v1-31-release/?utm_source=chatgpt.com "Kubernetes v1.31: Elli"))|
|7|**C**|AI‑driven DevOps는 **자동화**를 지향하며 수동 승인 확대와 무관([CTO Magazine](https://ctomagazine.com/key-devops-trend-2025-to-follow-2/ "Key DevOps Trends for 2025 and Beyond: What Tech Leaders Must Prepare For - CTO Magazine"))|
|8|**B**|Shift‑left Security는 보안을 **코딩/CI 초기**에 통합([CTO Magazine](https://ctomagazine.com/key-devops-trend-2025-to-follow-2/ "Key DevOps Trends for 2025 and Beyond: What Tech Leaders Must Prepare For - CTO Magazine"))|
|9|**B**|통합 목적은 테스트·보안 **포함**이며 생략이 아님([TechRadar](https://www.techradar.com/pro/breaking-silos-unifying-devops-and-mlops-into-a-unified-software-supply-chain "Breaking silos: unifying DevOps and MLOps into a unified software supply chain \| TechRadar"))|
|10|**C**|Atlassian은 Agile·CI/CD·자동화·피드백을 강조, 워터폴은 포함하지 않음([Atlassian](https://www.atlassian.com/devops/what-is-devops/devops-best-practices "DevOps Best Practices \| Atlassian"))|
|11|**D**|Green DevOps는 리소스 **최적화**로 에너지 절감, 과도한 선점은 반대([CTO Magazine](https://ctomagazine.com/key-devops-trend-2025-to-follow-2/ "Key DevOps Trends for 2025 and Beyond: What Tech Leaders Must Prepare For - CTO Magazine"))|
|12|**A**|Git 저장소를 **단일 소스 오브 트루스**로 사용, 변경 추적·자동 롤백·감사 용이([CTO Magazine](https://ctomagazine.com/key-devops-trend-2025-to-follow-2/ "Key DevOps Trends for 2025 and Beyond: What Tech Leaders Must Prepare For - CTO Magazine"))|

---

### 🐳 쿠버네티스 기본‑중급 문제

1. **[기본]** 파드(Pod)에 대한 설명으로 **옳지 않은** 것은?  
    A. 쿠버네티스에서 가장 작은 배포 단위다.  
    B. 여러 컨테이너를 하나의 네트워크 네임스페이스로 묶는다.  
    C. 항상 노드(Node) 하나에만 스케줄될 수 없다.  
    D. 파드가 죽으면 쿠버네티스가 자동으로 재시작하거나 교체한다.
    
2. **[기본]** `kubectl get pods` 명령어에 `-o wide` 옵션을 붙이면 **추가로 확인할 수 있는 정보**는?  
    A. 파드 레이블 목록  
    B. 파드가 올라간 노드 이름  
    C. 파드 생성 시각  
    D. 파드 이벤트 로그
    
3. **[중]** **Deployment** 리소스의 주된 목적 두 가지를 고르면? _(복수 정답)_  
    A. 파드의 스케줄링 우선순위 지정  
    B. 이미지 롤링 업데이트 관리  
    C. 원하는 파드 수(Replica) 유지  
    D. 서비스(LoadBalancer) 자동 생성
    
4. **[중]** 다음 중 **서비스(Service)** 의 ClusterIP 타입이 **주로 해결해 주는 문제**는?  
    A. 외부에서 파드를 직접 접근할 수 없는 문제  
    B. 파드 IP가 재시작 시 바뀌어 통신이 끊기는 문제  
    C. 파드 간 CPU/메모리 과다 사용 문제  
    D. 네트워크 정책이 적용되지 않는 문제
    
5. **[중급]** 다음 YAML 조각은 어떤 **오브젝트 종류**를 정의한 것인가?
    
    `apiVersion: v1 kind: ConfigMap metadata:   name: app-config data:   LOG_LEVEL: "debug"   TIMEOUT: "5"`
    
    A. Secret  
    B. ConfigMap  
    C. PersistentVolumeClaim  
    D. LimitRange
    
6. **[중급]** **Horizontal Pod Autoscaler (HPA)** 를 사용하려면 기본적으로 **필수인 구성 요소**를 모두 고른 것은? _(복수 정답)_  
    A. 메트릭 서버(Metrics Server)  
    B. cgroup v2 지원 커널  
    C. 리소스 요청/제한(`resources.requests`) 설정  
    D. NetworkPolicy

|#|정답|해설|
|---|---|---|
|1|**C**|파드는 항상 **하나의 노드**에만 스케줄된다.|
|2|**B**|`-o wide` 로 노드(Node) 이름·IP 등을 추가 확인 가능.|
|3|**B,C**|Deployment는 롤링 업데이트와 Replica 관리가 핵심 기능.|
|4|**B**|ClusterIP는 파드 IP 변동을 가려주는 **내부 가상 IP** 제공.|
|5|**B**|`kind: ConfigMap` 으로 설정 데이터를 저장하는 오브젝트.|
|6|**A,C**|HPA는 **Metrics Server** 로 메트릭 수집, 파드에 **리소스 요청** 값이 있어야 스케일 기준 계산 가능.|

**11. Kubernetes에서 Pod Disruption Budget(PDB)이 다음과 같이 설정되어 있을 때, 노드 드레인 중 발생할 상황은?**

```yaml
spec:
  minAvailable: 3
  selector:
    matchLabels:
      app: critical-app
```

현재 해당 레이블의 Pod가 5개 실행 중이고, 2개는 Node A에, 3개는 Node B에 있다.

A) Node A 드레인 시 즉시 모든 Pod가 evict됨  
B) Node B 드레인 시 3개 Pod 중 2개만 evict되고 1개는 대기  
C) Node B 드레인 시 모든 Pod evict가 차단됨  
D) PDB는 자발적 중단에만 적용되므로 드레인과 무관

**정답: B (minAvailable=3이므로 Node B의 3개 중 2개만 evict 가능)**

---

**12. Admission Webhook에서 Mutating과 Validating의 실행 순서와 특징으로 올바른 것은?**

A) Validating이 먼저 실행되고, 둘 다 객체 수정 가능  
B) Mutating이 먼저 실행되고, Validating은 검증만 가능  
C) 동시에 실행되며, 하나라도 실패하면 요청 거부  
D) 순서는 무작위이며, Mutating만 객체 수정 가능

**정답: B (Mutating → Validating 순서, Validating은 수정 불가)**

---

**13. CRI(Container Runtime Interface)와 관련하여 틀린 설명은?**

A) kubelet과 컨테이너 런타임 간의 표준 인터페이스  
B) Docker는 CRI를 직접 구현하지 않아 dockershim이 필요했음  
C) containerd와 CRI-O는 CRI를 네이티브로 지원  
D) CRI는 이미지 빌드 기능도 포함함

**정답: D (CRI는 컨테이너 런타임 인터페이스로 이미지 빌드는 포함하지 않음)**

---

**14. Kubernetes에서 HPA와 VPA를 동시에 사용할 때 주의사항으로 맞는 것은?**

A) 절대 함께 사용할 수 없음  
B) CPU/Memory 모두에 대해 동시 적용 가능  
C) CPU는 HPA, Memory는 VPA로 분리하면 안전  
D) updateMode: "Off"로 VPA를 설정하고 추천값만 참고

**정답: D (VPA를 추천 모드로만 사용하는 것이 안전)**

---

**15. StatefulSet의 Pod가 다음 순서로 장애가 발생했을 때, 복구 순서는?**

- app-2 (Pending)
- app-0 (CrashLoopBackOff)
- app-1 (Running)
- app-3 (Pending)

A) app-0 → app-2 → app-3 순서로 복구  
B) app-2 → app-3 → app-0 순서로 복구  
C) 모든 Pod가 동시에 복구 시도  
D) app-1이 Running이므로 다른 Pod 복구 불가

**정답: A (StatefulSet은 순서 보장, app-0부터 복구)**

---

**16. Observability의 Three Pillars에서 Logs, Metrics, Traces의 관계로 틀린 것은?**

A) Traces는 여러 서비스 간의 요청 흐름을 추적  
B) Metrics는 시계열 데이터로 집계된 정보 제공  
C) Logs는 구조화되지 않은 이벤트 정보  
D) Traces는 Metrics를 대체할 수 있음

**정답: D (Traces는 Metrics를 대체하지 못함, 서로 보완 관계)**

---

**17. Feature Flag/Toggle을 사용한 배포 전략의 장점이 아닌 것은?**

A) 코드 배포와 기능 릴리즈를 분리  
B) A/B 테스트 수행 가능  
C) 런타임 성능 향상  
D) 즉각적인 롤백 가능

**정답: C (Feature Flag는 런타임 오버헤드 발생)**

---

**18. GitOps와 관련하여 Push 방식 대비 Pull 방식의 장점으로 틀린 것은?**

A) 클러스터 내부에서 외부로의 연결만 필요  
B) Git 저장소의 접근 권한만으로 보안 관리  
C) 배포 속도가 더 빠름  
D) 클러스터별 인증 정보 중앙 관리 불필요

**정답: C (Pull 방식은 폴링 주기 때문에 Push보다 느릴 수 있음)**

---

**19. Chaos Engineering 실험 설계 시 고려하지 않아도 되는 것은?**

A) Blast Radius 최소화  
B) 평상시 시스템 동작의 가설 수립  
C) 모든 장애 시나리오를 한 번에 테스트  
D) 실험 중단 메커니즘 준비

**정답: C (점진적으로 실험 범위를 확대해야 함)**

---

**20. Service Level Indicators(SLI) 설정 시 좋은 예시가 아닌 것은?**

A) 95 percentile 응답 시간 < 200ms  
B) 성공한 요청 수 / 전체 요청 수  
C) 평균 CPU 사용률 < 80%  
D) 특정 기간 동안의 가용성 %

**정답: C (CPU 사용률은 원인이지 사용자 경험을 나타내는 지표가 아님)**

---

**21. Kubernetes에서 Progressive Delivery를 구현할 때, Flagger가 Canary 배포 중 메트릭을 평가하는 방식은?**

A) 단일 메트릭이 실패하면 즉시 롤백  
B) 모든 메트릭이 임계값을 통과해야 다음 단계 진행  
C) 메트릭 평가 없이 시간 기반으로만 진행  
D) 이전 버전과의 상대적 비교만 수행

**정답: B (모든 메트릭 통과 시 다음 단계)**

---

**22. OpenTelemetry에서 Context Propagation이 중요한 이유는?**

A) 로그 파일 크기를 줄이기 위해  
B) 분산 시스템에서 요청을 추적하기 위해  
C) 메트릭 수집 성능을 높이기 위해  
D) 데이터 암호화를 위해

**정답: B (분산 추적을 위한 컨텍스트 전파)**

---

**23. Kubernetes Operator 패턴에서 Reconciliation Loop가 아닌 것은?**

A) Observe - 현재 상태 확인  
B) Analyze - 원하는 상태와 비교  
C) Approve - 사용자 승인 대기  
D) Act - 차이를 해결하기 위한 조치

**정답: C (Operator는 자동화가 목적, 사용자 승인 대기는 해당 없음)**

---

**24. Zero Trust Security Model을 Kubernetes에 적용할 때 해당하지 않는 것은?**

A) 모든 Pod 간 통신에 mTLS 적용  
B) NetworkPolicy로 필요한 통신만 허용  
C) 클러스터 내부 트래픽은 신뢰  
D) RBAC으로 최소 권한 원칙 적용

**정답: C (Zero Trust는 내부도 신뢰하지 않음)**

---

**25. Platform Engineering과 DevOps의 차이점으로 가장 적절한 것은?**

A) Platform Engineering은 DevOps를 대체하는 새로운 방법론  
B) Platform Engineering은 개발자 경험 향상을 위한 내부 플랫폼 구축에 중점  
C) DevOps는 도구 중심, Platform Engineering은 문화 중심  
D) Platform Engineering은 운영팀만의 책임

**정답: B (개발자 셀프서비스 플랫폼 제공이 핵심)**

---

**26. Kubernetes API Server의 요청 처리 과정에서 다음 중 가장 마지막에 실행되는 것은?**  
A) Authentication  
B) Admission Control  
C) Authorization  
D) API Object Validation  
**정답: B**

---

**27. kubelet의 Pod 생성 과정에서 Pause Container의 역할이 아닌 것은?**  
A) Pod 내 네트워크 네임스페이스 유지  
B) Pod 내 컨테이너 간 로그 수집  
C) PID 네임스페이스 유지 (shareProcessNamespace 활성화 시)  
D) Pod의 IP 주소 할당 대상  
**정답: B**

---

**28. Kubernetes에서 CPU Manager Policy가 "static"일 때 적용되는 조건은?**  
A) 모든 Pod에 자동 적용  
B) Guaranteed QoS + 정수 CPU request/limit  
C) BestEffort QoS Pod만 적용  
D) Node의 CPU 사용률이 80% 이상일 때  
**정답: B**

---

**29. Extended Resource를 사용하여 GPU를 할당할 때, 다음 중 불가능한 것은?**  
A) 단일 Pod에 여러 GPU 할당  
B) GPU 메모리 크기 지정  
C) 특정 벤더의 GPU만 요청  
D) Node별 GPU 개수 광고  
**정답: B**

---

**30. Kubernetes Scheduler의 Predicate와 Priority 단계에서 맞는 설명은?**  
A) Priority 계산 후 Predicate 필터링  
B) Predicate는 하드 요구사항, Priority는 소프트 선호사항  
C) 둘 다 점수 기반으로 평가  
D) Custom Scheduler는 Priority만 수정 가능  
**정답: B**

---

### Prometheus & Grafana

**31. Prometheus의 Pull 모델에서 Service Discovery 설정이 올바른 것은?**

```yaml
- job_name: 'kubernetes-pods'
  kubernetes_sd_configs:
  - role: pod
  relabel_configs:
  - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
    action: keep
    regex: true
```

A) prometheus.io/scrape: "true" 어노테이션이 있는 Pod만 수집  
B) 모든 Pod를 수집하되 어노테이션으로 필터링  
C) Pod의 모든 포트에서 메트릭 수집  
D) Service를 통해서만 메트릭 수집  
**정답: A**

---

**32. PromQL에서 다음 쿼리의 의미는?**

```
rate(http_requests_total[5m]) > bool 0.1
```

A) 5분간 요청 증가율이 0.1 이상인 경우 true  
B) 5분간 초당 요청 수가 0.1 이상이면 1, 아니면 0  
C) 5분간 총 요청 수가 0.1 이상  
D) 매 5분마다 0.1개 이상의 요청  
**정답: B**

---

### Istio Service Mesh

**33. Istio에서 Circuit Breaker 설정 시 consecutiveErrors: 5의 의미는?**  
A) 총 5개의 에러가 발생하면 차단  
B) 연속으로 5개의 에러가 발생하면 차단  
C) 5초 동안 에러가 지속되면 차단  
D) 5%의 에러율이 발생하면 차단  
**정답: B**

---

**34. Istio VirtualService에서 다음 설정의 동작은?**

```yaml
spec:
  http:
  - match:
    - headers:
        x-user-type:
          exact: premium
    route:
    - destination:
        host: premium-service
  - route:
    - destination:
        host: standard-service
```

A) 모든 요청을 premium-service로 라우팅  
B) x-user-type 헤더가 없으면 에러 발생  
C) premium 헤더가 있으면 premium-service, 없으면 standard-service  
D) 두 서비스에 50:50으로 분산  
**정답: C**

---

### ArgoCD

**35. ArgoCD의 Sync Policy에서 automated.prune: true의 의미는?**  
A) Git에서 삭제된 리소스를 클러스터에서도 자동 삭제  
B) 오래된 이미지를 자동으로 정리  
C) 실패한 동기화를 자동으로 재시도  
D) 불필요한 리비전 히스토리 삭제  
**정답: A**

---

**36. ArgoCD App of Apps 패턴의 주요 이점이 아닌 것은?**  
A) 애플리케이션 간 의존성 관리  
B) 단일 진입점으로 여러 앱 관리  
C) 애플리케이션별 독립적인 권한 설정  
D) 동기화 성능 향상  
**정답: D**

---

### Terraform

**37. Terraform에서 다음 코드의 문제점은?**

```hcl
resource "aws_instance" "web" {
  count = var.instance_count
  ami = "ami-12345678"
  instance_type = "t2.micro"
  
  provisioner "remote-exec" {
    inline = [
      "sudo apt-get update",
      "sudo apt-get install -y nginx"
    ]
  }
}
```

A) count와 provisioner를 함께 사용할 수 없음  
B) provisioner는 안티패턴이며 user_data나 구성 관리 도구 사용 권장  
C) remote-exec는 AWS에서 지원하지 않음  
D) ami ID를 하드코딩하면 안 됨  
**정답: B**

---

**38. Terraform State Lock의 목적은?**  
A) State 파일 암호화  
B) 동시 수정 방지  
C) State 파일 백업  
D) 민감 정보 마스킹  
**정답: B**

---

### Jenkins

**39. Jenkins Pipeline에서 다음 코드의 실행 결과는?**

```groovy
pipeline {
    agent any
    stages {
        stage('Build') {
            parallel {
                stage('Unit Test') {
                    steps { sh 'sleep 10' }
                }
                stage('Integration Test') {
                    steps { sh 'sleep 5' }
                }
            }
        }
    }
}
```

A) 총 15초 소요  
B) 총 10초 소요  
C) 총 5초 소요  
D) 순서가 정의되지 않아 에러 발생  
**정답: B**

---

**40. Jenkins의 Blue Ocean과 관련하여 틀린 설명은?**  
A) 파이프라인 시각화 개선  
B) 기존 Jenkinsfile과 호환  
C) 선언적 파이프라인만 지원  
D) Git 브랜치별 파이프라인 자동 생성  
**정답: C**

---

### Elastic Stack (ELK)

**41. Elasticsearch에서 다음 설정의 의미는?**

```json
{
  "index.number_of_shards": 3,
  "index.number_of_replicas": 2
}
```

A) 총 3개의 샤드 생성  
B) 총 6개의 샤드 생성  
C) 총 9개의 샤드 생성  
D) 노드 수에 따라 동적 결정  
**정답: C**

---

**42. Logstash Pipeline에서 다음 필터의 순서가 중요한 이유는?**

```
filter {
  mutate { 
    split => { "message" => " " }
  }
  grok {
    match => { "message" => "%{TIMESTAMP_ISO8601:timestamp}" }
  }
}
```

A) mutate가 message 필드를 배열로 변경해서 grok 실패  
B) 성능상 mutate를 먼저 실행해야 함  
C) grok 패턴이 잘못됨  
D) 순서는 상관없음  
**정답: A**

---

### Ansible

**43. Ansible에서 다음 태스크의 changed 상태를 방지하는 방법은?**

```yaml
- name: Check service status
  command: systemctl status nginx
  register: nginx_status
```

A) `when: false` 추가  
B) `changed_when: false` 추가  
C) `check_mode: yes` 추가  
D) `ignore_errors: true` 추가  
**정답: B**

---

**44. Ansible Vault로 암호화된 변수를 사용할 때 Best Practice는?**  
A) 모든 변수를 하나의 vault 파일에 저장  
B) vault 파일명에 _vault 접미사 사용  
C) 평문 변수와 vault 변수를 같은 파일에 혼용  
D) Git에 vault 패스워드 파일 저장  
**정답: B**

---

### Helm

**45. Helm 3에서 다음 명령어의 차이점은?**

```bash
helm install myapp ./chart
helm upgrade --install myapp ./chart
```

A) 차이 없음  
B) upgrade --install은 이미 존재하면 업그레이드, 없으면 설치  
C) install은 네임스페이스를 자동 생성  
D) upgrade는 롤백 히스토리를 보존하지 않음  
**정답: B**

---

**71. Kubernetes에서 Pod가 사용하는 실제 메모리가 limit을 초과했을 때와 request를 초과했을 때의 차이는?**

A) 둘 다 즉시 OOMKilled  
B) limit 초과 시 OOMKilled, request 초과 시는 노드 메모리 부족 시에만 evict 고려  
C) request 초과 시 OOMKilled, limit 초과 시는 경고만  
D) 차이 없음

**정답: B**

**72. Kubernetes 1.24 버전 이후 Dockershim이 제거된 주된 이유는?**

A) Docker의 보안 취약점  
B) CRI 표준을 직접 구현하지 않아 유지보수 부담  
C) Docker 라이선스 문제  
D) 성능이 containerd보다 느림

**정답: B**

**73. Pod의 restartPolicy: OnFailure와 Job의 관계에서 맞는 것은?**

A) Job은 항상 restartPolicy: Never만 사용  
B) Container가 성공(exit 0)하면 재시작하지 않음  
C) Pod 레벨에서 재시작이 아닌 새 Pod 생성  
D) restartPolicy는 Job에서 무시됨

**정답: B**

**74. Headless Service (ClusterIP: None)를 사용하는 주된 이유가 아닌 것은?**

A) StatefulSet에서 각 Pod에 직접 접근  
B) DNS를 통한 Pod IP 목록 조회  
C) 로드 밸런싱 비활성화  
D) Service IP 자원 절약

**정답: D**

**75. kubectl debug 명령어로 디버깅 컨테이너를 추가할 때 장점이 아닌 것은?**

A) 실행 중인 Pod에 영향 없이 디버깅 도구 사용  
B) 원본 컨테이너의 네트워크 네임스페이스 공유  
C) 원본 컨테이너의 파일시스템 직접 수정 가능  
D) distroless 이미지 디버깅 가능

**정답: C**

## 데브옵스 개념 & 방법론

**76. Continuous Deployment와 Continuous Delivery의 주요 차이점은?**

A) Deployment는 자동 테스트, Delivery는 수동 테스트  
B) Deployment는 프로덕션까지 자동 배포, Delivery는 수동 승인 필요  
C) Deployment는 빠른 배포, Delivery는 안전한 배포  
D) 차이 없이 같은 의미

**정답: B**

**77. Immutable Infrastructure의 핵심 원칙이 아닌 것은?**

A) 서버를 배포 후 수정하지 않음  
B) 변경이 필요하면 새로 배포  
C) 설정 변경을 위한 SSH 접속 금지  
D) 애플리케이션 로그는 내부에 저장

**정답: D**

**78. DevOps에서 "Shift Right" 접근법이 의미하는 것은?**

A) 개발 일정을 뒤로 미루기  
B) 프로덕션 환경에서의 모니터링과 피드백 강화  
C) 운영팀의 책임을 개발팀으로 이전  
D) 배포 주기를 늦추기

**정답: B**

**79. DORA Metrics에 포함되지 않는 것은?**

A) Deployment Frequency  
B) Lead Time for Changes  
C) Code Coverage  
D) Mean Time to Recovery

**정답: C**

**80. Canary 배포에서 "Canary Analysis"가 평가하는 항목이 아닌 것은?**

A) 에러율 비교  
B) 응답 시간 비교  
C) 리소스 사용량 비교  
D) 코드 복잡도 비교

**정답: D**

## 쿠버네티스 네트워킹 & 보안

**81. Kubernetes에서 CNI 플러그인이 반드시 구현해야 하는 것은?**

A) 네트워크 정책 적용  
B) Pod에 IP 할당 및 제거  
C) 로드 밸런싱  
D) DNS 해석

**정답: B**

**82. NetworkPolicy에서 namespaceSelector와 podSelector를 모두 지정했을 때의 동작은?**

```yaml
- from:
  - namespaceSelector:
      matchLabels:
        env: prod
    podSelector:
      matchLabels:
        app: frontend
```

A) prod 네임스페이스의 모든 Pod + 현재 네임스페이스의 app=frontend Pod  
B) prod 네임스페이스에 있는 app=frontend Pod만  
C) 조건 중 하나만 만족해도 허용  
D) 문법 오류

**정답: B**

**83. RBAC에서 Role과 ClusterRole을 동시에 가진 ServiceAccount의 권한은?**

A) ClusterRole이 Role을 덮어씀  
B) Role이 우선 적용됨  
C) 두 권한의 합집합  
D) 네임스페이스 내에서는 Role, 클러스터 레벨은 ClusterRole

**정답: C**

**84. Pod Security Standards에서 Baseline 정책이 제한하는 것은?**

A) 모든 컨테이너는 non-root로 실행  
B) hostNetwork, hostPID, hostIPC 사용  
C) 읽기 전용 루트 파일시스템  
D) 모든 capabilities 드롭

**정답: B**

**85. Kubernetes API에 대한 Anonymous 요청이 가능한 경우는?**

A) 항상 차단됨  
B) system:anonymous 사용자에게 권한이 부여된 경우  
C) 인증 실패 시 자동으로 anonymous 처리  
D) kube-public 네임스페이스 접근 시

**정답: B**

## 모니터링 & 옵저버빌리티

**86. RED Method에서 추적하는 메트릭이 아닌 것은?**

A) Rate (요청 비율)  
B) Errors (에러율)  
C) Duration (지연 시간)  
D) Dependency (의존성)

**정답: D**

**87. Distributed Tracing에서 Span의 관계를 나타내는 것이 아닌 것은?**

A) Parent-Child  
B) Follows-From  
C) Bidirectional  
D) Reference

**정답: C**

**88. SLI(Service Level Indicator)의 좋은 예시가 아닌 것은?**

A) 99 백분위수 응답 시간  
B) 성공한 요청의 비율  
C) 서버의 CPU 사용률  
D) 사용자가 경험한 가용성

**정답: C**

**89. Observability와 Monitoring의 차이점으로 가장 적절한 것은?**

A) 같은 개념의 다른 표현  
B) Observability는 왜(why)를 이해하고, Monitoring은 무엇(what)을 추적  
C) Monitoring이 더 포괄적인 개념  
D) Observability는 로그만, Monitoring은 메트릭만 다룸

**정답: B**

**90. Golden Signals에 포함되지 않는 것은?**

A) Latency  
B) Traffic  
C) Errors  
D) Utilization

**정답: D**

## 쿠버네티스 스토리지

**91. PersistentVolume의 Access Mode가 ReadWriteMany인 경우 지원하지 않는 스토리지 타입은?**

A) NFS  
B) AWS EBS  
C) CephFS  
D) GlusterFS

**정답: B**

**92. StorageClass의 reclaimPolicy: Retain일 때 PVC 삭제 시 동작은?**

A) PV와 실제 스토리지 모두 삭제  
B) PV는 Released 상태가 되고 실제 스토리지는 유지  
C) PV는 삭제되고 실제 스토리지는 유지  
D) 아무 일도 일어나지 않음

**정답: B**

**93. CSI(Container Storage Interface) 드라이버가 제공하는 기능이 아닌 것은?**

A) 동적 볼륨 프로비저닝  
B) 볼륨 스냅샷  
C) 볼륨 크기 조정  
D) 파일 시스템 포맷 변경

**정답: D**

**94. ephemeral volume 타입이 아닌 것은?**

A) emptyDir  
B) configMap  
C) downwardAPI  
D) hostPath

**정답: D**

**95. Volume Mount Propagation에서 Bidirectional 설정이 필요한 경우는?**

A) 읽기 전용 마운트  
B) 컨테이너 내부에서 마운트한 것을 호스트에서도 보이게 할 때  
C) 여러 컨테이너가 볼륨 공유  
D) NFS 볼륨 사용 시

**정답: B**

## CI/CD & 자동화

**96. GitOps에서 Pull 방식의 단점은?**

A) 보안이 취약함  
B) 폴링 주기에 따른 지연 발생  
C) Git 저장소 접근 권한 관리 복잡  
D) 롤백이 어려움

**정답: B**

**97. Feature Branch 전략에서 발생할 수 있는 문제가 아닌 것은?**

A) 장기간 유지 시 머지 충돌 증가  
B) 통합 지연으로 인한 Integration Hell  
C) 코드 리뷰 부담 증가  
D) 히스토리 추적 불가

**정답: D**

**98. Semantic Versioning(SemVer)에서 MINOR 버전을 올리는 경우는?**

A) 버그 수정  
B) 하위 호환성을 유지하며 기능 추가  
C) 하위 호환성을 깨는 변경  
D) 문서만 수정

**정답: B**

**99. Infrastructure as Code의 "Drift"가 발생하는 원인이 아닌 것은?**

A) 수동으로 리소스 변경  
B) 코드 저장소 업데이트  
C) 클라우드 프로바이더의 기본값 변경  
D) 외부 시스템과의 통합 변경

**정답: B**

**100. Blue-Green 배포의 단점이 아닌 것은?**

A) 리소스를 2배로 사용  
B) 데이터베이스 마이그레이션 처리 복잡  
C) 롤백이 느림  
D) 세션 처리 고려 필요

**정답: C**

이제 100문제를 모두 제공했습니다! 특정 주제를 더 깊이 다루거나 다른 유형의 문제가 필요하시면 말씀해주세요.